<section>
<section>

<h2>Tecnologías de Producción de Software</h2>

<p><img src="images/00/ruby.png" alt="Ruby logo"></p>

<h1>Ruby</h1>

</section>
</section>

<section>
<section>

<h1>Presentación</h1>

</section>
<section>

<h2>La cátedra</h2>

<ul>
<li>
<strong>Profesor:</strong> Lic. Christian A. Rodríguez 
<a href="mailto:car@info.unlp.edu.ar" title="car@info.unlp.edu.ar"><img src="images/assets/mail.png" alt="car@info.unlp.edu.ar"></a>
<a href="https://twitter.com/car_unlp" title="twitter"><img src="images/assets/twitter.png" alt="twitter"></a>
<a href="https://github.com/chrodriguez" title="github"><img src="images/assets/github.png" alt="github"></a>
</li>
<li>
<strong>JTP:</strong> Lic. Nahuel Cuesta Luengo
<a href="mailto:ncuesta@cespi.unlp.edu.ar" title="ncuesta@cespi.unlp.edu.ar"><img src="images/assets/mail.png" alt="ncuesta@cespi.unlp.edu.ar"></a>
<a href="https://twitter.com/ncuestal" title="twitter"><img src="images/assets/twitter.png" alt="twitter"></a> 
<a href="https://github.com/ncuesta" title="github"><img src="images/assets/github.png" alt="github"></a>
</li>
<li>
<strong>Ayudante:</strong> Lic. Patricio Mac Adden 
<a href="mailto:patriciomacadden@gmail.com" title="patriciomacadden@gmail.com"><img src="images/assets/mail.png" alt="patriciomacadden@gmail.com"></a> 
<a href="https://twitter.com/maxawen" title="twitter"><img src="images/assets/twitter.png" alt="twitter"></a> 
<a href="https://github.com/patriciomacadden" title="github"><img src="images/assets/github.png" alt="github"></a>
</li>
<li>
<strong>Ayudante:</strong> Lautaro De León 
<a href="mailto:ldeleon@cespi.unlp.edu.ar" title="ldeleon@cespi.unlp.edu.ar"><img src="images/assets/mail.png" alt="ldeleon@cespi.unlp.edu.ar"></a>
<a href="https://github.com/lndl" title="github"><img src="images/assets/github.png" alt="github"></a>
</li>
</ul>

</section>
<section>

<h2>Horarios de cursada</h2>

<ul>
<li><strong>Martes de 11 a 13 Aula 10-A</strong></li>
<li><strong>Jueves de 11 a 13 Aula 10-A</strong></li>
</ul>

</section>
<section>

<h2>Programa</h2>

<ul>
<li>Introducción</li>
<li>VMs: MRI, Rubinius, jRuby</li>
<li>Preparación del entorno</li>
<li>Objetos, arreglos, hashes, símbolos, tipos estándar</li>
<li>Estructuras de control</li>
<li>Bloques e iteradores</li>
<li>E/S estandar</li>
<li>Clases de objetos, métodos y variables</li>
<li>Módulos y mixins</li>
<li>TDD</li>
</ul>

</section>
<section>

<h2>Programa (continuación)</h2>

<ul>
<li>Gemas: rubygems</li>
<li>Rake</li>
<li>Bundler</li>
<li>HTTP</li>
<li>La web

<ul>
<li>Rack</li>
<li>Sinatra</li>
<li>ORMs</li>
<li>Rails</li>
</ul>
</li>
<li>Deploy de aplicaciones ruby</li>
</ul>

</section>
<section>

<h2>Modalidad de cursada</h2>

<ul>
<li>Clases teórico prácticas: generalmente avanzaremos con las teorías los días
martes, dejando los jueves para consultas o talleres prácticos</li>
<li>Aprobación de la cursada: <em>será necesario aprobar</em>

<ul>
<li>Entregas de un ejercicio por práctico que se desarrollará en clase. Habrá
una evaluación por práctico (salvo el primero)</li>
<li>Trabajo práctico final integrador</li>
</ul>
</li>
<li>Aprobación de la materia mediante extensión del trabajo práctico y coloquio</li>
</ul>

</section>
<section>

<h2>Bibliografía / Recursos</h2>

<ul>
<li>A medida que se presenten los temas se indicarán las fuentes apropiadas</li>
<li>Todo el material se encuentra bajo licencia <strong>Creative Commons</strong>
</li>
</ul>

<p><small>
<span xmlns:dct="http://purl.org/dc/terms/" property="dct:title">TTPS - Opcion Ruby</span> por 
<span xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName">Christian A. Rodriguez</span> se encuentra bajo
una <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">Licencia Creative Commons Atribución-NoComercial-CompartirIgual 3.0 Unported</a>.
<br>
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.es">
<img alt="Licencia Creative Commons" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png"></a>
</small></p>

</section>
</section>

<section>
<section>

<h1>Introducción a Ruby</h1>

</section>
<section>

<h1>Historia</h1>

</section>
<section>

<p><img src="images/01/yukihiro-matsumoto.jpg" alt="Yukihiro Matsumoto"></p>

<h3>MATZ</h3>

</section>
<section>

<h2>MATZ</h2>

<ul>
<li>
<a href="http://en.wikipedia.org/wiki/Yukihiro_Matsumoto">Yukihiro Matsumoto</a>

<ul>
<li>En japonés: 松本行弘 (まつもとゆきひろ)</li>
<li>Matz más simple</li>
<li>Empezó el desarrollo de Ruby en 1993</li>
<li>En 1995 lanzó la primera versión</li>
<li>Aún lidera el desarrollo de Ruby</li>
</ul>
</li>
<li>Su célebre frase:</li>
</ul>

<p>Ruby is designed to make programmers <strong>HAPPY</strong></p>

</section>
<section>

<h2>¿Cómo surge Ruby?</h2>

<ul>
<li>Fusión de lenguajes

<ul>
<li>Smalltalk</li>
<li>Perl</li>
<li>LISP</li>
</ul>
</li>
<li>Hasta el 2001 conocido sólo en Japón

<ul>
<li>El libro <a href="http://pragprog.com/book/ruby/programming-ruby">Programming Ruby</a> fue el 
impulsor del lenguaje fuera de Japón</li>
<li>También conocido como PickAxe</li>
<li>La primera versión puede <a href="http://ruby-doc.org/docs/ProgrammingRuby/">leerse en línea</a>
</li>
</ul>
</li>
</ul>

</section>
<section>

<p><img src="images/01/pickaxe.jpg" alt="pickaxe"></p>

</section>
<section>

<h2>En el 2005, en Dinamarca aparece DHH...</h2>

<p><img src="images/01/dhh.jpg" alt="DHH"></p>

</section>
<section>

<h2>DHH</h2>

<ul>
<li>
<a href="http://en.wikipedia.org/wiki/David_Heinemeier_Hansson">David Heinemeier Hansson</a> creador de Rails</li>
<li>
<a href="http://rubyonrails.org/">Rails</a>

<ul>
<li>Framework open source para desarrollo de aplicaciones web</li>
<li>Creado en 2004</li>
<li>Su primer versión liberada (1.0) fue en 2005</li>
<li>Actualmente en la versión 5.2</li>
</ul>
</li>
</ul>

<p><img src="images/01/rails.png" alt="Rails"></p>

</section>
<section>

<h1>El lenguaje</h1>

</section>
<section>

<h2>Características</h2>

<ul>
<li>Dinámico</li>
<li>Sintaxis concisa y expresiva </li>
<li>Orientado a objetos</li>
<li>Capacidades de metaprogramación</li>
<li>Características funcionales</li>
</ul>

</section>
<section>

<h2>Sintaxis y convenciones</h2>
<pre><code class="ruby">
  NombreDeClaseOModulo

  CONSTANTE

  @nombre_de_atributo

  @@atributo_de_clase

  $variable_global

  nombre_de_metodo

  metodo_peligroso!

  metodo_que_pregunta?

</code></pre>
</section>
<section>

<h2>Objetos</h2>

<p>Todos los valores son <strong>objetos</strong></p>
<pre><code class="ruby">
"Aprendiendo ruby".length

</code></pre>
</section>
<section>

<h2>Arreglos</h2>
<pre><code class="ruby">
["Mateo", "Lola", "Lihue", "Clio"].sort

</code></pre>
<h2>Números</h2>
<pre><code class="ruby">
-100.abs

</code></pre>
<h2>nil</h2>
<pre><code class="ruby">
nil.nil?

</code></pre>
</section>
<section>

<h2>Más ejemplos</h2>
<pre><code class="ruby">
1.object_id

nil.object_id

</code></pre>
<h3>Simple y conciso</h3>
<pre><code class="ruby">
([1,2,3] + [4,5,6]).last

</code></pre>
</section>
<section>

<h2>Literales</h2>

<h3>Números literales</h3>
<pre><code class="ruby">
3
3.14
1_999_235_243_888 == 1999235243888

</code></pre>
<h3>Binario, octal o hexadecimal</h3>
<pre><code class="ruby">
0b1000_1000   # Binario     =&gt;  136
010           # Octal       =&gt;    8
0x10          # Hexadecimal =&gt;   16

</code></pre>
</section>
<section>

<h2>Strings literales</h2>
<pre><code class="ruby">
'sin interpolar'
"Interpolando: #{'Ja'*3}!"

# Otra forma de escribir un string
%q/Hola/
%q!Chau!
%Q{Interpolando: #{3+3}}

</code></pre>
<h2>Strings como here document</h2>
<pre><code class="ruby">un_string = &lt;&lt;EOS
  Este es un texto
  de mas de una linea
  que termina aqui
EOS

un_string.upcase
</code></pre>
</section>
<section>

<h2>Símbolos</h2>

<ul>
<li>Son como variables prefijados con <strong>:</strong> (dos puntos)

<ul>
<li>Ejemplos: <code>:action</code>, <code>:line_items</code>, <code>:+</code>
</li>
</ul>
</li>
<li>No es necesario declararlos </li>
<li>Se garantiza que son únicos

<ul>
<li>No es necesario asignarles ningún valor</li>
</ul>
</li>
</ul>
<pre><code class="ruby">
:uno.object_id  # siempre devolverá lo mismo
"uno".object_id # siempre devolverá diferente

</code></pre>
</section>
<section>

<h2>Arreglos</h2>
<pre><code class="ruby">
['Hola', 'Chau']

%w(Hola Chau #{2+2})  # sin interpolar

%W(Hola Chau #{2+2})  # interpolando

[1,2,3,4]
</code></pre>
<h2>Hashes</h2>
<pre><code class="ruby"># Versión 1.8
{
  :nombre   =&gt; 'Christian',
  :apellido   =&gt; 'Rodriguez'
}
# Versión &gt; 1.8
{
  nombre:   'Christian',
  apellido:   'Rodriguez'
}
</code></pre>
</section>
<section>

<h2>Expresiones regulares</h2>
<pre><code class="ruby">
/^[a-zA-Z]+$/

</code></pre>
<p><em>Explicación detallada en
<a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/language.html#UJ">Pickaxe</a></em></p>

<p><em>Para probar expresiones regulares puede usar <a href="http://rubular.com/">Rubular</a></em></p>

</section>
<section>

<h2>Rangos</h2>
<pre><code class="ruby">
0..1
0..10
"a".."z"
"a"..."z"

# Pueden convertirse en arreglos
("a"..."z").to_a

# Rangos como intervalos
(1..10) === 5     # =&gt; true
(1..10) === 15    # =&gt; false
(1..10) === 3.1   # =&gt; true

</code></pre>
</section>
<section>

<h2>Lambdas</h2>
<pre><code class="ruby">uno = lambda { |n| n * 2 }

dos = -&gt;(n, m){ n * 2 + m }

tres  = -&gt;(n, m=0){ n * 2 + m}

# Entonces

uno.call 2      # =&gt; 4

dos.call 2,3    # =&gt; 7

tres.call 2     # =&gt; 4
</code></pre>
</section>
<section>

<h2>Métodos como operadores</h2>
<pre><code class="ruby">
10 - 2

# Es equivalente a:
10.send :-, 2

# Operadores con arreglos
[1,2,3] - [1]

</code></pre>
</section>
<section>

<h2>Expresiones</h2>

<p>En Ruby toda expresión retorna un valor </p>
<pre><code>a = 3.14 # =&gt; 3.14

# Veamos el case
estado = nil
face =  case estado
        when "Feliz"  then ":)"
        when "Triste" then ":("
        else               ":|"
end

</code></pre>
</section>
<section>

<h2>¿Qué retorna la siguiente expresión?</h2>
<pre><code class="ruby">
def foo
  "bar"
end

</code></pre>
<p><strong>Su ejecución retorna <code>"bar"</code></strong></p>

<p><small class="fragment">
En versiones previas a la 2.0 retorna <strong>nil</strong>, en versiones superiores el símbolo
con el nombre del método</small></p>

<p></p>

</section>
<section>

<h2>Bloques</h2>

<p>Rara vez usaremos un for / while</p>
<pre><code class="ruby">
3.times do |i|
  puts i
end

# Imprime:
#  0
#  1
#  2
# Retorna 3 (que es quien recibe el método :times)

# También es posible
3.times { |i| puts i }

</code></pre>
</section>
<section>

<h2>Programando declarativamente</h2>
<pre><code class="ruby">
# Los pares
(1..10).select { |n| n.even? }

# o lo que es igual:
(1..10).select(&amp; :even?)

# Procesando cada elemento
(1..10).map { |n| n*2 }

# o lo que es igual:
(1..10).collect { |n| n*2 }

</code></pre>
</section>
<section>

<h2>Más ejemplos</h2>
<pre><code class="ruby">
(1..100).reduce { |sum,n| sum + n }

# o lo que es igual:
(1..100).reduce(:+)

# La formula de verificacion es: n*(n+1)/2
100*101/2
</code></pre>
</section>
<section>

<h2>Aumentando la fluidez</h2>
<pre><code class="ruby">
File.open('/etc/passwd').each do |line|
  puts line if line =~ /root/
end
</code></pre>
</section>
<section>

<h2>¿Qué es duck typing?</h2>

<ul>
<li>Es un término empleado en <strong>OO</strong>
</li>
<li>Estilo de tipeo dinámico donde:

<ul>
<li>Los métodos y propiedades determinan la semántica válida</li>
<li>No se basa en el uso de herencia o interfaces para indicar la propiedad: <strong>es un
..</strong>
</li>
</ul>
</li>
<li>El nombre del concepto se refiere al <em>duck test</em>, atribuído a James Whitcomb
Riley que podría resumirse en:</li>
</ul>

<p><em>Si veo un pájaro que camina como pato, nada como pato y hace "cuack" como pato,
entonces llamaré a ese pájaro un pato</em></p>

</section>
<section>

<h2>Duck typing en Java</h2>
<pre><code class="java">public interface DuckLike {
  Cuack cuack();
}
//...
public void doSomething(DuckLike d) {
  d.cuack();
//  ...
}
</code></pre>
</section>
<section>

<h2>En Java debemos usar reflexión</h2>
<pre><code class="java">import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DuckTyping {

  interface Walkable  { void walk(); }
  interface Swimmable { void swim(); }
  interface Quackable { void quack(); }

  public static void main(String[] args) {
    Duck d = new Duck();
    Person p = new Person();

    as(Walkable.class, d).walk();   //duck can walk()
    as(Swimmable.class, d).swim();  //duck can swim() 
    as(Quackable.class, d).quack(); //duck can quack()

    as(Walkable.class, p).walk();   //person can walk()
    as(Swimmable.class, p).swim();  //person can swim() 
    // Gives Runtime Error
    as(Quackable.class, p).quack(); //person can't quack()
  }
  @SuppressWarnings("unchecked")
  static &lt;T&gt; T as(Class&lt;T&gt; t, final Object obj) {
    return (T) Proxy.newProxyInstance(t.getClassLoader(), 
      new Class[] {t},
      new InvocationHandler() {
        public Object invoke(Object proxy, 
              Method method, 
              Object[] args) throws Throwable {
          try {
            return obj.getClass()
              .getMethod(method.getName(), 
                 method.getParameterTypes())
              .invoke(obj, args);
          } catch (NoSuchMethodException nsme) {
            throw new NoSuchMethodError(
              nsme.getMessage());
          } catch (InvocationTargetException ite) {
            throw ite.getTargetException();
          }
        }
      });
  }
}
</code></pre>
</section>
<section>

<h2>Las clases Duck y Person</h2>
<pre><code class="java">class Duck {
  public void walk()  {
    System.out.println("I'm Duck, I can walk...");
  }
  public void swim()  {
    System.out.println("I'm Duck, I can swim...");
  }
  public void quack() {
    System.out.println("I'm Duck, I can quack...");
  }
}

class Person {
  public void walk()  {
    System.out.println("I'm Person, I can walk...");
  }
  public void swim()  {
    System.out.println("I'm Person, I can swim...");
  }
  public void talk()  {
    System.out.println("I'm Person, I can talk...");
  }
}
</code></pre>
</section>
<section>

<h1>En Ruby</h1>
<pre><code class="ruby">class Duck
  def quack
    puts "Quaaaaaack!"
  end
  def feathers
    puts "The duck has white and gray feathers."
  end
end
class Person
  def quack
    puts "The person imitates a duck."
  end
  def feathers
    puts "The person takes a feather from the ground"
  end
end
def in_the_forest(duck)
  duck.quack
  duck.feathers
end

donald = Duck.new
john = Person.new
in_the_forest donald
in_the_forest john
</code></pre>
</section>
<section>

<h2>¿Qué es monkey patching?</h2>

<ul>
<li>Modificar una clase dinámicamente</li>
<li>En tiempo de ejecución, agregar nuevos métodos a una clase o cambiar su
comportamiento</li>
<li>El término surge de <strong>Gorilla Patch</strong> 

<ul>
<li><em>Monkey patch es menos intimidante</em></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Monkey patching: ejemplo</h2>
<pre><code class="ruby">(1..10).even # da error: even no existe

class Range
  # Agregamos even a Range
  def even
    self.select(&amp; :even?)  
  end
end

(1..10).even # ahora no da error
# =&gt; [2,4,6,8,10]
</code></pre>
</section>
<section>

<h2>Módulos como Namespace</h2>
<pre><code class="ruby">module MyAPI
  class User
  ...
  end

  def self.configuration
  ...
  end
end

user = MyAPI::User.new

puts MyAPI::configuration
</code></pre>
</section>
<section>

<h2>Módulos como Mixins</h2>

<p><em>Como las interfaces, pero con comportamiento</em></p>
<pre><code class="ruby">module MyLog
  def log(msg)
    puts "Log: #{msg}"
  end
end
</code></pre>
<p><em>¿Cómo usar un mixin?</em></p>
<pre><code class="ruby">class String; include MyLog; end

"hola".log("pepe")
</code></pre>
</section>
<section>

<h2>Referencias</h2>

<ul>
<li><a href="http://www.ruby-doc.org/docs/ProgrammingRuby/">PickAxe</a></li>
<li><a href="http://www.rubyinside.com/media/poignant-guide.pdf">why's (poignant) Guide to Ruby</a></li>
<li>Muy inspirado en la gran presentación de Jano González presentada en la
RubyConf 2012 Argentina

<ul>
<li><a href="https://speakerdeck.com/janogonzalez/donde-estan-mis-interfaces">¿Donde están mis interfaces?</a></li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h1>Ruby VMs</h1>

</section>
<section>

<h2>MRI</h2>

<ul>
<li>Matz' Ruby Implementation</li>
<li>También llamada CRuby</li>
<li>Es la implementación de referencia del lenguaje</li>
<li>Últimas versiones

<ul>
<li>1.8.7-p375 (No usar!)</li>
<li>1.9.3-p551</li>
<li>2.0.0-p547</li>
<li>2.1.10</li>
<li>2.2.5</li>
<li>2.3.1</li>
<li>2.4.4</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>JRuby</h2>

<ul>
<li>Ruby en la JVM</li>
<li>Es la alternativa más madura a MRI en términos de compatibilidad con MRI</li>
<li>Combina lo mejor de la plataforma de la JVM con Ruby:

<ul>
<li>Concurrencia real</li>
<li>Interoperabilidad con librerías Java</li>
</ul>
</li>
<li>Últimas versiones

<ul>
<li>jruby-9.2.0.0</li>
</ul>
</li>
<li>Modos

<ul>
<li>1.8.x</li>
<li>1.9.x </li>
<li>2.x</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Rubinius</h2>

<ul>
<li>Ruby escrito en (mayoritariamente) Ruby</li>
<li>La VM fue escrita en C++</li>
<li>El bytecode compiler y una gran parte de las clases Core de Ruby fueron escritas en Ruby</li>
<li>Últimas versiones

<ul>
<li>rbx-3.105</li>
<li>rbx-2.11</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Otras implementaciones</h2>

<ul>
<li>IronRuby

<ul>
<li>Ruby en .NET</li>
<li>El proyecto está inactivo</li>
</ul>
</li>
<li>MagLev: 

<ul>
<li>Ruby en la VM GemStone/S 3.1 de VMware (Smalltalk!)</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Referencias</h2>

<ul>
<li>MRI

<ul>
<li><a href="http://ruby-lang.org">http://ruby-lang.org</a></li>
<li><a href="https://github.com/ruby/ruby">https://github.com/ruby/ruby</a></li>
</ul>
</li>
<li>JRuby: Referencias

<ul>
<li><a href="http://jruby.org/">http://jruby.org/</a></li>
<li><a href="https://github.com/jruby/jruby">https://github.com/jruby/jruby</a></li>
</ul>
</li>
<li>Rubinius: Referencias

<ul>
<li><a href="http://rubini.us/">http://rubini.us/</a></li>
<li><a href="https://github.com/rubinius/rubinius">https://github.com/rubinius/rubinius</a></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Referencias</h2>

<ul>
<li>Otras implementaciones: referencias

<ul>
<li><a href="http://ironruby.codeplex.com/">http://ironruby.codeplex.com/</a></li>
<li><a href="https://github.com/ironlanguages/main">https://github.com/ironlanguages/main</a></li>
<li><a href="http://macruby.org/">http://macruby.org/</a></li>
<li><a href="https://github.com/MacRuby/MacRuby">https://github.com/MacRuby/MacRuby</a></li>
<li><a href="http://maglev.github.io/">http://maglev.github.io/</a></li>
<li><a href="https://github.com/MagLev/maglev">https://github.com/MagLev/maglev</a></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Instalando Ruby</h2>

<p>Muchas implementaciones</p>

<p>¿Cual usar?</p>

<p>¿Y si necesito o quiero usar más de 1?</p>

<h2>Un pequeño paréntesis</h2>

<p>Gemas</p>

<p>Bundler</p>

</section>
<section>

<h2>RVM</h2>

<ul>
<li>Ruby Version Manager</li>
<li>Fue la primera herramienta para instalar, administrar y trabajar con múltiples entornos de Ruby</li>
<li>Introduce el concepto de gemset</li>
<li>Modifica el comando <code>cd</code> para cambiar de versión de ruby</li>
</ul>

</section>
<section>

<h2>rbenv</h2>

<ul>
<li>Ruby environment</li>
<li>Fue la primera alternativa a RVM y rápidamente se hizo muy popular</li>
<li>Es más simple que RVM y ya no instala rubies ni usa gemsets</li>
<li>Se puede agregar funcionalidad con plugins</li>
<li><strong>Es la opción que explicaremos</strong></li>
</ul>

</section>
<section>

<h1>Instalando rbenv</h1>

</section>
<section>

<h2>Instalando rbenv</h2>

<p>La instalación se realiza con <strong>git</strong> en el directorio <code>~/.rbenv</code></p>
<pre><code class="bash">
git clone https://github.com/sstephenson/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile

# En ubuntu, hacer el `echo` en `.bashrc` en vez de `.bash_profile`
# Agregamos `rbenv init` al shell para habilitar el autocompletado

echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile

</code></pre>
<p><small>
<em>En ubuntu, hacer el <code>echo</code> en <code>.bashrc</code> en vez de <code>.bash_profile</code></em>
</small></p>

<p><strong>Debemos reiniciar el shell para que tome cambios</strong></p>
<pre><code>
$ exec $SHELL -l

</code></pre>
<p><small>
<em>Con rbenv podemos seleccionar qué ruby usar. <strong>No instala ruby</strong></em>
</small></p>

</section>
<section>

<h2>Plugin para instalar ruby</h2>

<p>Es necesario instalar <strong>ruby-build</strong> en el directorio <code>~/.rbenv/plugins</code></p>
<pre><code class="bash">
git clone https://github.com/sstephenson/ruby-build.git \
  ~/.rbenv/plugins/ruby-build

</code></pre>
</section>
<section>

<h2>rbenv: Comandos</h2>

<ul>
<li>
<strong><code>rbenv versions</code></strong>: muestra las versiones instaladas de ruby (con un * la versión actual)</li>
<li>
<strong><code>rbenv global</code></strong>: muestra o setea la versión global de ruby</li>
<li>
<strong><code>rbenv local</code></strong>: identico al comando anterior, pero para el directorio actual</li>
<li>
<strong><code>rbenv install</code></strong>: instala rubies! (con <code>-l</code> listamos todas las versiones disponibles)</li>
</ul>

</section>
<section>

<h2>Referencias</h2>

<ul>
<li><a href="https://rvm.io/">https://rvm.io/</a></li>
<li><a href="https://github.com/sstephenson/rbenv">https://github.com/sstephenson/rbenv</a></li>
<li><a href="https://github.com/sstephenson/ruby-build">https://github.com/sstephenson/ruby-build</a></li>
</ul>

</section>
</section>

<section>
<section>

<h1>Objetos y atributos</h1>

</section>
<section>

<h2>Objetos y atributos</h2>

<ul>
<li><p>Luego de haber visto la <em>Introducción a Ruby</em>, ya conocemos un poco sobre la sintáxis de este lenguaje</p></li>
<li><p>Para entender mejor los objetos, vamos a hacerlo mediante un ejemplo
tomado del libro Programming Ruby (Pick Axe)</p></li>
</ul>

</section>
<section>

<h3>El problema: Librería de reventa de libros</h3>

<ul>
<li><p>Reventa de libros usuados que realiza control de stock semanalmente</p></li>
<li><p>Mediante lectores de códigos de barra se registra cada libro en las 
bibliotecas. Cada lector, genera un archivo separado por comas (CSV) que contiene 
una fila para cada libro registrado.</p></li>
<li><p>Cada fila contiene entre otros datos: ISBN del libro y precio. Un extracto del
archivo sería:</p></li>
</ul>
<pre><code class="csv">"Date","ISBN","Amount"
"2008-04-12","978-1-9343561-0-4",39.45
"2008-04-13","978-1-9343561-6-6",45.67
"2008-04-14","978-1-9343560-7-4",36.95
</code></pre>
</section>
<section>

<h2>¿Qué tenemos que hacer?</h2>

<ul>
<li>Tomar todos los CSV de cada lectora y determinar cuántos ejemplares de cada
título disponemos</li>
<li>Determinar además el monto total en libros que tenemos</li>
</ul>

</section>
<section>

<h2>Creamos la clase Book In Stock</h2>

<p><em>Recordamos que los nombres de las clases deben comenzar con mayúsculas, los
métodos con minúscula</em></p>
<pre><code class="ruby">
class BookInStock
end

</code></pre>
<h3>Lo probamos:</h3>
<pre><code class="ruby">
a_book = BookInStock.new
another_book = BookInStock.new

</code></pre>
</section>
<section>

<h2>Pero en el ejemplo anterior:</h2>

<ul>
<li>Se crean dos objetos diferentes de la clase <code>BookInStock</code>. </li>
<li><p>Podríamos decir en esta primer instancia que son el mismo libro, o iguales porque <strong>nada los
distingue</strong></p></li>
<li><p>Lo solucionamos obligando que la inicialización indique aquellos datos que distinga al
libro</p></li>
</ul>

</section>
<section>

<h2>La nueva implementación</h2>
<pre><code class="ruby">
class BookInStock
  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end

</code></pre>
<ul>
<li>El método <code>initialize</code> es especial en Ruby </li>
<li>Cuando se invoca el método <code>new</code>, Ruby aloca memoria para alojar un objeto no
inicializado y luego invoca al método <code>initialize</code> <strong>pasándole cada parámetro
que fue enviado a <code>new</code></strong>
</li>
<li>Entonces <code>initialize</code> nos permite configurar el estado inicial de nuestros objetos</li>
</ul>

</section>
<section>

<h2>Continuamos analizando</h2>

<ul>
<li>El método <code>initialize</code>:

<ul>
<li>Vemos que se utilizan variables de instancia: 

<ul>
<li>Comienzan con <strong>@</strong>
</li>
<li>Esto permite que los valores recibidos como parámetros no se pierdan luego
de ejecutar <code>initialize</code>
</li>
<li>Por ello almacenamos estos valores en variables de instancia</li>
</ul>
</li>
</ul>
</li>
<li>Podríamos pensar que <code>@isbn</code> e <code>isbn</code> están relacionadas, pero:

<ul>
<li>No hay relación alguna más que coinciden en el nombre</li>
<li>Pero ambas son variables diferentes, una con un nombre que comienza con
<strong>@</strong> y otra <strong>no</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Continuamos analizando</h2>

<ul>
<li>Notamos además que se realiza una pequeña validación

<ul>
<li>El método
<a href="http://www.ruby-doc.org/core-2.0.0/Kernel.html#method-i-Float"><code>Float</code></a>
toma un argumento y lo convierte a <code>float</code>, terminando el programa si falla
la conversión</li>
</ul>
</li>
</ul>

<p><em>Analizar cómo es que <code>Float</code> es un método</em></p>

</section>
<section>

<h2>Usamos los nuevos objetos</h2>
<pre><code class="ruby">b1 = BookInStock.new("isbn1", 3)
p b1
b2 = BookInStock.new("isbn2", 3.14)
p b2
b3 = BookInStock.new("isbn3", "5.67")
p b3
</code></pre>
<ul>
<li>Usamos el método <code>p</code> porque imprime el estado interno de los objetos.</li>
<li>
<code>to_s</code>, que es enviado a cualquier objeto que necesita convertirse a <code>string</code> </li>
<li>
<code>puts</code> por defecto imprime: </li>
</ul>
<pre><code class="ruby">
  #&lt;nombre_de_clase:id_objeto_en_hex&gt;

</code></pre>
</section>
<section>

<h2>Modificamos la conversión a string</h2>
<pre><code class="ruby">class BookInStock
  def to_s
    "ISBN: #{@isbn}, price: #{@price}"
  end
end
</code></pre>
</section>
<section>

<h2>Objetos y sus atributos</h2>

<ul>
<li>Un objeto como el mostrado anteriormente no permite que nadie acceda a sus
variables</li>
<li>Si bien es algo positivo encapsular, si no permitimos acceder a los datos que
mantienen el estado del objeto, el mismo se vuelve inútil.</li>
<li>A las <em>ventanas</em> de acceso a los objetos las denominaremos <strong>atributos</strong>
</li>
<li>Modificaremos nuestra clase de <code>BookInStock</code> con el fin de agregar atributos
para <code>isbn</code> y <code>price</code> así podemos contabilizarlos</li>
</ul>

</section>
<section>

<h2>Getters</h2>
<pre><code class="ruby">class BookInStock
  def isbn
    @isbn 
  end

  def price
    @price
  end
end
</code></pre>
</section>
<section>

<h2>Acceso a los atributos</h2>

<ul>
<li>A los atributos anteriores se los denomina <code>accesor</code> porque mapean
directamente con las variables de instancia

<ul>
<li>Ruby provee un shortcut: <code>attr_reader</code>
</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class BookInStock
  attr_reader :isbn, :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
  # ..
end
</code></pre>
<ul>
<li>Notar que se utilizan <strong>símbolos</strong>
</li>
<li>
<code>attr_reader</code> <strong>no define variables de instancia</strong>

<ul>
<li>Sólo los métodos de acceso</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Atributos de escritura</h2>

<ul>
<li>No sólo leemos atributos: a veces necesitamos modificar un valor</li>
<li>Ruby permite modificar atributos definiendo un método terminado con <strong>el signo
igual</strong>:</li>
</ul>

<h3>Agregamos <code>price=</code>
</h3>
<pre><code class="ruby">class BookInStock
  attr_reader :isbn, :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price=(new_price)
    @price = new_price
  end
  # ...
end
</code></pre>
</section>
<section>

<h2>Atributos de escritura</h2>
<pre><code class="ruby">book = BookInStock.new("isbn1", 33.80)
puts "ISBN = #{book.isbn}"
puts "Price = #{book.price}"
book.price = book.price * 0.75 # discount price
puts "New price = #{book.price}"
</code></pre>
<ul>
<li>
<code>attr_writer</code> provee acces de escritura únicamente</li>
<li>
<code>attr_accessor</code> provee acceso R/W</li>
</ul>

<h3>La clase definitiva:</h3>
<pre><code class="ruby">class BookInStock

  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end
end
</code></pre>
</section>
<section>

<h2>Atributos virtuales</h2>

<p><em>Agregamos el precio en centavos</em></p>
<pre><code class="ruby">class BookInStock
  attr_reader :isbn
  attr_accessor :price

  def initialize(isbn, price)
    @isbn = isbn
    @price = Float(price)
  end

  def price_in_cents
    Integer(price*100 + 0.5)
  end

  def price_in_cents=(cents)
    @price = cents / 100.0
  end
end
</code></pre>
<p><small>
No hay correspondencia con variables de instancia como es el caso de <code>price</code> e <code>isbn</code>.
<br> <strong>El mapeo es con <code>price</code></strong>
</small></p>

</section>
<section>

<h2>El lector de CSV</h2>

<ul>
<li>Repasamos qué debemos implementar:

<ul>
<li>Leer varios archivos CSV</li>
<li>Totalizar ejemplares iguales</li>
<li>Totalizar el precio de los libros en stock</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>El esqueleto de <code>CsvReader</code>
</h2>
<pre><code class="ruby">class CsvReader
  def initialize
    # ...
  end

  def read_in_csv_data(csv_file_name)
  # ...
  end

  def total_value_in_stock
  # ...
  end

  def number_of_each_isbn
  # ...
  end
end
</code></pre>
</section>
<section>

<h2>¿Cómo usríamos CsvReader?</h2>
<pre><code class="ruby">reader = CsvReader.new
reader.read_in_csv_data("file1.csv")
reader.read_in_csv_data("file2.csv")
# ......
# ......
puts "Total value in stock =  #{reader.total_value_in_stock}"
</code></pre>
<ul>
<li>Notamos que <code>CsvReader</code> debe ir acumulando lo que va leyendo de cada csv</li>
<li>Para ello mantendremos un arreglo de valores como variable de instancia</li>
<li>Para leer un CSV, Ruby provee de una librería que simplificará el trabajo</li>
</ul>

</section>
<section>

<h2>Comportamiento de CsvReader</h2>
<pre><code class="ruby">require 'csv'

class CsvReader

  def initialize
    @books_in_stock = []
  end

  def read_in_csv_data(csv_file_name)
    CSV.foreach(csv_file_name, headers: true) do |row|
      @books_in_stock &lt;&lt; 
        BookInStock.new(row["ISBN"], row["Amount"])
    end
  end
end
</code></pre>
<p><small>
<ul>
  <li>La primer línea de <code>read_in_csv_data</code> indica la apertura del archivo
<code>csv_file_name</code> y el parámetro <code>headers: true</code> indica a la librería que la
primer línea del archivo son los encabezados de cada columna o campo</li>
  <li>La librería pasará entonces cada fila leída al bloque mostrado</li>
  <li>Notar que el acceso a cada campo se corresponde con los <strong>nombres de las columnas</strong>
</li>
</ul>
</small></p>

</section>
<section>

<h2>Calculando el precio total</h2>
<pre><code class="ruby">class CsvReader

  # Luego veremos como usar inject...
  def total_value_in_stock
    sum = 0.0
    @books_in_stock.each do |book| 
      sum += book.price
    end
    sum
  end

end
</code></pre>
</section>
<section>

<h2>Fragmentación de un programa</h2>

<ul>
<li>Dividimos el código en tres archivos

<ul>
<li>
<code>book_in_stock.rb</code>: la clase <code>BookInStock</code>
</li>
<li>
<code>csv_reader.rb</code>: el código de <code>CsvReader</code>
</li>
<li>
<code>stock_stats.rb</code>: el programa principal</li>
</ul>
</li>
<li>Aparecerán dependencias entre ellos

<ul>
<li>Para cargar dependencias externas se utiliza: <code>require</code> y <code>require_relative</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h3><code>stock_stats.rb</code></h3>
<pre><code class="ruby">require_relative 'csv_reader'

reader = CsvReader.new
ARGV.each do |csv_file_name|
  STDERR.puts "Processing #{csv_file_name}"
  reader.read_in_csv_data(csv_file_name)
end

puts "Total value = #{reader.total_value_in_stock}"
</code></pre>
<p><small>
<a href="images/samples/03/stock_stats.zip">Descargar ejemplo completo</a>
</small></p>
<pre><code class="bash">awk -F',' \
  'begin {total = 0} {total += $3} END {print "total: " total}' \
  csv_samples/*csv
</code></pre>
<p><small>
Comprobación con AWK
</small></p>

</section>
</section>

<section>
<section>

<h1>Clases</h1>

</section>
<section>

<h2>Control de acceso</h2>

<ul>
<li>Al diseñar la interfaz de una clase es importante definir qué publicaremos al
mundo</li>
<li>Permitir demasiado acceso a nuestras clases, incrementará el riesgo de
<strong>acoplamiento</strong> de la aplicación

<ul>
<li>Los usuarios de una clase que se expone demasiado podrían confiar en
detalles de implementación en vez de su interfaz lógica</li>
</ul>
</li>
<li>Ruby provee control de acceso a los métodos (que son quienes permitirían
alterar el estado de un objeto)</li>
<li>Una regla importante es:

<ul>
<li>Nunca exponer métodos que puedan dejar un objeto en estado inválido</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Niveles de protección</h2>

<ul>
<li>
<strong>Públicos:</strong> los métodos públicos pueden invocarse por cualquiera (no hay
control de acceso). Los métodos son públicos por defecto excepto initialize que
siempre es privado.</li>
<li>
<strong>Protegidos:</strong> pueden invocarse sólo por objetos de la clase que lo define y 
sus subclases. El acceso queda en la familia.</li>
<li>
<strong>Privados:</strong> estos métodos no pueden ser invocados con un receptor explícito: 
<em>el receptor es siempre el objeto actual, mejor conocido como <code>self</code></em>. Esto
significa que tampoco puede invocar el método privado de otra instancia de la
misma clase.</li>
</ul>

</section>
<section>

<h2>Aplicando accesos</h2>
<pre><code class="ruby">class MyClass
  def method  # default is public
  end

  protected   # subsequent methods will be 'protected'
  def method2
  end

  private     # subsequent methods will be 'private'
  def method3
  end

  public      # subsequent methods will be 'public'
  def method4
  end
end
</code></pre>
</section>
<section>

<h2>Alternativamente</h2>
<pre><code class="ruby">class MyClass
  def method1; end
  def method2; end
  def method3; end
  def method4; end

  public :method1, :method4
  protected :method2
  private :method3
end
</code></pre>
</section>
</section>

<section>
<section>

<h1>Variables</h1>

</section>
<section>

<h2>Variables</h2>

<ul>
<li>Hemos usado variables en varias oportunidades</li>
<li>Se usan para no perder valores y poder referenciarlos nuevamente</li>
<li>Cada variable es una <strong>referencia</strong> a un objeto</li>
<li>Son lo único que no son objetos en ruby: </li>
</ul>

<p><em>Is a variable an object?</em> <strong><em>In Ruby, the answer is no.</em></strong> <em>A variable is simply a
reference to an object. Objects float around in a big pool somewhere (the heap, most of the
time) and are pointed to by variables.</em></p>

</section>
<section>

<h2>Variables como alias</h2>

<p>Analicemos el siguiente ejemplo</p>
<pre><code class="ruby">person1 = "Tim"
person2 = person1
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
</code></pre>
<h3>Para evitarlo: <code>dup</code>
</h3>
<pre><code class="ruby">person1 = "Tim"
person2 = person1.dup
person1[0] = 'J'
puts "person1 is #{person1}"
puts "person2 is #{person2}"
</code></pre>
</section>
<section>

<h2>Freezando un objeto</h2>

<p>Es posible freezar objetos</p>
<pre><code class="ruby">person1 = "Tim"
person2 = person1
person1.freeze
person2[0] = 'J'
</code></pre>
</section>
</section>

<section>
<section>

<h1>Colecciones</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Las colecciones representan elementos fundamentales de cualquier programa</li>
<li>Ruby provee dos clases que representan colecciones: 

<ul>
<li><code>array</code></li>
<li>
<code>hash</code> o  arreglo asociativo</li>
</ul>
</li>
<li>El correcto uso de estas colecciones es fundamental en la programación Ruby</li>
<li>Los bloques, combinados con colecciones se convierten en construcciones muy
poderosas para la iteración</li>
</ul>

</section>
<section>

<h2>Array</h2>

<ul>
<li>La clase <code>Array</code> mantiene una colección de referencias a objetos. </li>
<li>Cada referencia a objeto ocupa una posición en el arreglo, identificada por un
índice entero no negativo</li>
</ul>

<h3>Ejemplos</h3>
<pre><code class="ruby">a = [ 3.14159, "pie", 99 ]
a.class
a.length
a[0]
a[1]
a[2]
a[3]

b = Array.new
b.class
b.length
b[0] = "second"
b[1] = "array"
b
</code></pre>
</section>
<section>

<h2>Arrays y <code>[]</code>
</h2>

<ul>
<li>Los elementos de un arreglo se acceden con el operador <code>[]</code>
</li>
<li>Pero <code>[]</code> es un método (de instancia en la clase <code>Array</code>) y por tanto puede
implementarse por cualquier subclase</li>
<li>El primer índice de un arreglo es el cero</li>
<li>Un arreglo accedido en un índice positivo retorna el objeto referenciado en
esa posición.

<ul>
<li>Si no hay objeto, retorna <code>nil</code>
</li>
</ul>
</li>
<li>Un arreglo accedido en un índice negativo, retorna el objeto contando desde el
final</li>
</ul>

</section>
<section>

<h2>Indices negativos</h2>
<pre><code class="ruby">a = [ 1, 7, 9]
a[-1]
a[-2]
a[-99]
</code></pre>
<h2>Indexando con un par de valores</h2>
<pre><code class="ruby">a = [ 1, 3, 5, 7, 9 ]
a[1, 3]
a[3, 1]
a[-3, 2]
</code></pre>
<p><small>
<em>Acceder arrays con dos valores indica <code>[start,count]</code> y retorna siempre un
nuevo <code>array</code></em>
</small></p>

</section>
<section>

<h2>Pueden usarse rangos</h2>
<pre><code class="ruby">a = [ 1, 3, 5, 7, 9]
a[1..3]
a[1...3]
a[3..3]
a[-3..-1]
</code></pre>
<ul>
<li>El rango indica los índices <strong>desde</strong> y <strong>hasta</strong>
</li>
<li>Usando <code>..</code> se incluye el fin de rango</li>
<li>Usando <code>...</code> se <strong>excluye</strong> el extremo final</li>
</ul>

</section>
<section>

<h2>Arrays y <code>[]=</code>
</h2>

<ul>
<li>El método <code>[]=</code> permite setear elementos de un array</li>
<li>Si se utiliza con un único índice, entonces reemplaza su valor por lo que esté
a la derecha de la asignación

<ul>
<li>Cualquier gap que haya quedado luego de <code>[]=</code> se completa con nil</li>
</ul>
</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="ruby">a = [ 1, 3, 5, 7, 9 ]
a[1] = 'bat'
a[-3] = 'cat'
a[3] = [ 9, 8 ]
a[6] = 99
</code></pre>
</section>
<section>

<h2>Arrays y <code>[]=</code>
</h2>

<ul>
<li>Si se utiliza con dos valores (inicio, cantidad) o un rango, luego estos
elementos son reemplazados por lo que esté a la derecha de la asignación

<ul>
<li>Si la cantidad de elementos a reemplazar es cero, entonces el valor 
es insertado en el array antes de la posición inicial: <strong>no se eliminan 
elementos</strong>
</li>
<li>Si el valor a la <strong>derecha es un arreglo</strong>, sus elementos se utilizan en el 
reemplazo: el tamaño del arreglo destino es actualizado si la cantidad de
elementos a la derecha difiere de los elementos a reemplazar</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo doble indexación</h2>

<p>Despejando las dudas con un ejemplo</p>
<pre><code class="ruby">a = [ 1, 3, 5, 7, 9 ]
a[2, 2] = 'cat'
a[2, 0] = 'dog'
a[1, 1] = [ 9, 8, 7 ]
a[0..3] = []
a[5..6] = 99, 98
</code></pre>
</section>
<section>

<h2>Arrays usados como pilas</h2>

<ul>
<li>Podemos invocar los siguientes métodos de <code>Array</code>

<ul>
<li><code>push</code></li>
<li><code>pop</code></li>
</ul>
</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="ruby">stack = []
stack.push "red"
stack.push "green"
stack.push "blue"
p stack
puts stack.pop
puts stack.pop
puts stack.pop
p stack
</code></pre>
</section>
<section>

<h2>Arrays usados como colas</h2>

<ul>
<li>Podemos invocar los siguientes métodos de <code>Array</code>

<ul>
<li><code>unshift</code></li>
<li><code>shift</code></li>
</ul>
</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="ruby">queue = []
queue.push "red"
queue.push "green"
puts queue.shift
puts queue.shift
</code></pre>
</section>
<section>

<h2>El principio y el final</h2>
<pre><code class="ruby">array = [ 1, 2, 3, 4, 5, 6, 7 ]
p array.first(4)
p array.last(4)
</code></pre>
</section>
<section>

<h2>Hashes</h2>

<ul>
<li>Los arreglos se indexan con enteros, los hashes con objetos

<ul>
<li>Símbolos, strings, expresiones regulares, etc</li>
</ul>
</li>
<li>Cuando se almacena un valor en un hash, utilizamos:

<ul>
<li>El índice, generalmente llamado <em>key</em>
</li>
<li>El dato a almacenar en dicho índice, generalmente llamado <em>valor</em>
</li>
</ul>
</li>
<li>El acceso a los valores referenciados por un hash se realiza por medio de los
<em>keys</em>
</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="ruby">h = { 'dog' =&gt; 'canine', 'cat' =&gt; 'feline' }
h.length # =&gt; 2
h['dog'] # =&gt; "canine"
h['cow'] = 'bovine'
h[12] = 'dodecine'
h['cat'] = 99
</code></pre>
</section>
<section>

<h2>Acceso a los hashes</h2>

<p>En el ejemplo anterior se utilizan strings como claves</p>

<h3>Ejemplo con símbolos</h3>
<pre><code class="ruby"># En ruby &gt;= 1.9
h = { dog: 'canine', cat: 'feline' }

# En ruby &lt; 1.9
h = { :dog =&gt; 'canine', :cat =&gt; 'feline' }
</code></pre>
<ul>
<li>Comparado a los arreglos, los hashes tienen una ventaja: se indexan con
objetos</li>
<li>A partir de la versión 1.9 además se recuerda el órden en que fueron
insertados los elementos

<ul>
<li>Cuando se itera sobre las entradas de un hash se respeta el orden de
inserción</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Un ejemplo usando Array y Hash</h2>

<h3>Frecuencia de palabras</h3>

<p><em>Calcular el número de veces que aparece una palabra en un texto</em></p>

<ul>
<li>El problema se divide en dos partes:

<ul>
<li>Separar el texto en palabras: <em>suena como un array</em>
</li>
<li>Luego contar cada palabra diferente: <em>suena como hash</em>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>La solución</h2>

<h3>El método que obtiene las palabras</h3>
<pre><code class="ruby">def words_from_string(string)
  string.downcase.scan(/[\w']+/)
end
</code></pre>
<h3>El método que cuenta las palabras</h3>

<ul>
<li>Usaremos un hash, indexado por las palabras a contar</li>
<li>El valor será la cantidad de ocurrencias 

<ul>
<li>Tendremos que incializar la primer ocurrencia en el valor 1 para luego sumar</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Una primer idea...</h2>

<p><em>Asumimos que counts es un <code>Hash</code></em></p>
<pre><code class="ruby">if counts.has_key?(next_word)
  counts[next_word] += 1
else
  counts[next_word] = 1
end
</code></pre>
</section>
<section>

<h2>Refactorizamos</h2>

<ul>
<li>Podemos ordenar un poco la idea anterior

<ul>
<li>
<code>Hash.new</code> puede recibir como parámetro el valor usado para incializar cada
valor del Hash. <em>(por ejemplo cuando se accede a un valor que no existe aún en
el Hash)</em>
</li>
</ul>
</li>
</ul>

<h3>Implementación</h3>
<pre><code class="ruby">def count_frequency(word_list)
  counts = Hash.new(0)
  for word in word_list
    counts[word] += 1
  end
  counts
end
</code></pre>
<p><small>
<a href="images/samples/06/words_frequency.zip">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Testeando nuestra solución</h2>

<ul>
<li>Aplicar un test rápido es una buena práctica.</li>
<li>Si bien lo veremos más adelante, vamos introduciendo el concepto</li>
<li>Utilizaremos un framework de test llamado <code>Minitest</code>
</li>
<li>Sólo explicaremos el método <code>assert_equal</code> que chequea si los dos parámetros 
que se le envían son iguales, indicando <strong>fuertemente</strong> si así no
sucede</li>
<li>Utilizaremos <strong>afirmaciones</strong> <em>(en inglés assertions)</em> para testear los dos
métodos implementados, uno por vez

<ul>
<li>He aquí la razón por la que se escribieron como métodos separados</li>
<li>Tener métodos diferentes permite testearlos en forma aislada</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Testing</h2>

<p>Testeamos <code>words_from_string</code></p>
<pre><code class="ruby">require_relative 'words_from_string.rb'
require 'minitest/autorun'

class TestWordsFromString &lt; Minitest::Test
  def test_empty_string
    assert_equal([], words_from_string(""))
    assert_equal([], words_from_string(" "))
  end
  def test_single_word
    assert_equal(["cat"], words_from_string("cat"))
    assert_equal(["cat"], words_from_string(" cat "))
  end
  def test_many_words
    assert_equal(["the", "cat", "sat", "on","the","mat"],
        words_from_string("the cat sat on the mat"))
  end
  def test_ignores_punctuation
    assert_equal(["the", "cat's", "mat"],
        words_from_string("&lt;the!&gt; cat's, -mat...-"))
  end
end
</code></pre>
<p><small>
En esta clase, los métodos que comienzan con <strong>test</strong> serán corridos
por el framework de testing
</small></p>

</section>
<section>

<h2>Testing</h2>

<p>Testeamos <code>count_frequency</code></p>
<pre><code class="ruby">require_relative 'count_frequency.rb'
require 'minitest/autorun'

class TestCountFrequency &lt; Minitest::Test
  def test_empty_list
    assert_equal({}, count_frequency([]))
  end
  def test_single_word
    assert_equal({"cat" =&gt; 1}, count_frequency(["cat"]))
  end
  def test_two_different_words
    assert_equal({"cat" =&gt; 1, "sat" =&gt; 1},
          count_frequency(["cat", "sat"]))
  end
  def test_two_words_with_adjacent_repeat
    assert_equal({"cat" =&gt; 2, "sat" =&gt; 1},
          count_frequency(["cat", "cat", "sat"]))
  end
  def test_two_words_with_non_adjacent_repeat
    assert_equal({"cat" =&gt; 2, "sat" =&gt; 1},
          count_frequency(["cat", "sat", "cat"]))
  end
end
</code></pre>
</section>
</section>

<section>
<section>

<h1>Bloques e iteradores</h1>

</section>
<section>

<h2>Bloques</h2>

<ul>
<li>Un bloque es código encerrado entre llaves o las palabras claves <code>do</code> y <code>end</code>
</li>
<li>Ambas formas son idénticas, salvo por la precedencia

<ul>
<li>Cuando el código del bloque entra en una línea usar {}</li>
<li>Cuando tiene más de una línea usar <code>do</code> / <code>end</code>
</li>
</ul>
</li>
<li>Los bloques pueden verse como métodos anónimos</li>
</ul>

</section>
<section>

<h2>Bloques</h2>

<ul>
<li>Pueden recibir parámetros, que se explicitan entre barras verticales <code>|</code>
</li>
<li>El código de un bloque no se ejecuta cuando se define, sino que se almacenará
para ser ejecutado más adelante</li>
<li>En ruby, los bloques sólo podrán usarse después de la <em>invocación</em> de algún
método

<ul>
<li>Si el método recibe parámetros, entonces aparecerá luego de ellos</li>
<li>Podría verse incluso como un parámetro extra que es pasado al método</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<p>Suma de los cuadrados de los números en un arreglo</p>
<pre><code class="ruby">sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end
puts sum
</code></pre>
<ul>
<li>El bloque se invoca para cada elemento en el arreglo</li>
<li>El elemento del arreglo es pasado al bloque en la variable <code>value</code>
</li>
<li>La variable <code>sum</code> declarada fuera del bloque es actualizada dentro del bloque</li>
</ul>

</section>
<section>

<h2>Bloques</h2>

<ul>
<li>
<strong>Regla importante:</strong> <em>si existe una variable en el bloque con el mismo
nombre que una variable dentro del alcance pero creada fuera del bloque, ambas serán la
misma variable. En el ejemplo hay sólo una variable <code>sum</code></em>
</li>
<li>Veremos que el comportamiento mencionado podremos cambiarlo</li>
<li>Si una variable aparece sólo en el bloque, entonces será local al mismo (como
<code>square</code>)</li>
</ul>

</section>
<section>

<h2>Los casos no esperados</h2>
<pre><code class="ruby"># assume Shape defined elsewhere
square = Shape.new(sides: 4) 
#
# .. lots of code
#
sum = 0
[1, 2, 3, 4].each do |value|
  square = value * value
  sum += square
end

puts sum
square.draw # BOOM!
</code></pre>
</section>
<section>

<h2>Mas casos</h2>

<p>No sucede lo mismo con los argumentos al bloque</p>
<pre><code class="ruby">value = "some shape"
[ 1, 2 ].each {|value| puts value }
puts value
</code></pre>
<p>Podemos solucionar el problema de <code>square</code></p>
<pre><code class="ruby">square = "some shape"
sum = 0
[1, 2, 3, 4].each do |value; square|
  square = value * value # different variable
  sum += square
end
puts sum
puts square
</code></pre>
</section>
<section>

<h2>La magia de los bloques</h2>

<ul>
<li>Mencionamos que los bloques se utilizan de forma adyacente a la llamada a un
método y que no se ejecutan en el momento en que aparecen en el código</li>
<li>Para lograr este comportamiento, dentro de un método cualquiera, podremos
invocar un bloque

<ul>
<li>Los bloques se invocarán como si fueran métodos</li>
<li>Para invocar un bloque se utiliza la sentencia <code>yield</code>
</li>
<li>Al invocar <code>yield</code> ruby invocará al código del bloque </li>
<li>Cuando el bloque finaliza, ruby devuelve el código inmediatamente al
finalizar el llamado a <code>yield</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de un bloque</h2>
<pre><code class="ruby">
def three_times
  yield
  yield
  yield
end

three_times { puts "Hola" }
</code></pre>
</section>
<section>

<h2>Parámetros a un bloque</h2>

<ul>
<li>Cuando utilizamos <code>yield</code> podemos enviarle un parámetro

<ul>
<li>El parámetro enviado se mapea con el definido en el bloque entre las barras
verticales</li>
</ul>
</li>
<li>Un bloque puede retornar un valor y ser usado en el método</li>
</ul>

</section>
<section>

<h2>Ejemplo de envío de parámetros</h2>
<pre><code class="ruby">
def fib_up_to(max)
  i1, i2 = 1, 1
  while i1 &lt;= max
    yield i1
    i1, i2 = i2, i1+i2
  end
end

fib_up_to(1000) {|f| print f, " " }

</code></pre>
</section>
<section>

<h2>Ejemplo de uso del valor retornado</h2>
<pre><code class="ruby">
class Array
  def my_find
    for i in 0...size
      value = self[i]
      return value if yield(value)
    end
    return nil
  end
end

(1..200).to_a.my_find {|x| x%5 == 0}

(1..200).to_a.my_find {|x| x == 0}

</code></pre>
</section>
<section>

<h2>Los iteradores</h2>

<ul>
<li>Las clases que implementan colecciones, como <code>Array</code> <em>hacen lo que hacen
mejor:</em>

<ul>
<li>Acceder a los elementos que contienen</li>
</ul>
</li>
<li>El comportamiento de qué hacer con cada elemento lo delegan a la aplicación

<ul>
<li>Permitiendo que nos concentremos sólo en un requerimiento particular</li>
<li>En los casos anteriores (<code>find</code>), sería encontrar un elemento para el cual
el criterio sea verdadero</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Los iteradores each y collect</h2>

<ul>
<li>El iterador <code>each</code> es el más simple 

<ul>
<li>Solo invoca <code>yield</code> para cada elemento</li>
</ul>
</li>
<li>El iterador <code>collect</code> también conocido como <code>map</code> 

<ul>
<li>Invoca <code>yield</code> para cada elemento. El resultado lo guarda en un nuevo 
arreglo que es <strong>retornado</strong>
</li>
</ul>
</li>
</ul>

<h2>Ejemplos</h2>
<pre><code class="ruby">[ 1, 3, 5, 7, 9 ].each {|i| puts i }

['k','h','m','t','w'].collect {|x| x.succ }
</code></pre>
</section>
<section>

<h2>Otros usos de iteradores</h2>

<ul>
<li>Los iteradores no solo se usan con array y hash</li>
<li>Su lógica es muy utilizada en clases de entrada / salida para retornar
líneas sucesivas o bytes</li>
</ul>

<h2>Ejemplo</h2>
<pre><code class="ruby">f = File.open("testfile")
f.each { |line| puts "The line is: #{line}"}
f.close
</code></pre>
<p>Y si necesitamos el índice</p>
<pre><code class="ruby">f = File.open("testfile")
f.each_with_index do |line, index| 
  puts "Line #{index} is: #{line}" 
end
f.close
</code></pre>
</section>
<section>

<h2>El caso de inject</h2>

<ul>
<li>Este iterador tiene un nombre <em>raro</em>
</li>
<li>Permite acumular un valor a lo largo de los miembros de una colección</li>
<li>Recibe un parámetro que es el valor inicial para comenzar a acumular

<ul>
<li>Si no se especifica <strong>toma el primer elemento de la colección</strong>
</li>
</ul>
</li>
</ul>

<h3>Ejemplos</h3>
<pre><code class="ruby">[1,3,5,7].inject(0) {|sum, element| sum+element}

[1,3,5,7].inject {|sum, element| sum+element}

[1,3,5,7].inject(1) {|prod, element| prod*element}

[1,3,5,7].inject {|prod, element| prod*element}
</code></pre>
</section>
<section>

<h2>El caso de inject</h2>

<p>Generando más mística para <code>inject</code></p>
<pre><code class="ruby">[1,3,5,7].inject(:+)


[1,3,5,7].inject 100, :+


[1,3,5,7].inject(:*)
</code></pre>
</section>
<section>

<h2>Enumerators</h2>

<ul>
<li>Los iteradores son muy cómodos pero:

<ul>
<li>Son parte de la colección y no una clase a parte</li>
<li>En otros lenguajes (como Java), las colecciones no implementan sus
iteradores, sino que son clases separadas (como por ejemplo la interfaz 
Iterator de Java)</li>
<li>Es complicado iterar dos colecciones simultáneamente</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Enumerators</h2>

<ul>
<li>La solución: clase <code>Enumerator</code>

<ul>
<li>Se obtiene de una colección con el método <code>to_enum</code> o <code>enum_for</code>
</li>
</ul>
</li>
</ul>

<h3>Ejemplo</h3>
<pre><code class="ruby">a = [ 1, 3, "cat" ]
h = { dog: "canine", fox: "lupine" }
# Create Enumerators
enum_a = a.to_enum
enum_h = h.to_enum
enum_a.next   # =&gt; 1
enum_h.next   # =&gt; [ :dog, "canine" ]
enum_a.next   # =&gt; 3
enum_h.next   # =&gt; [ :fox, "lupine" ]
</code></pre>
</section>
<section>

<h2>Enumerators a partir de iteradores</h2>

<p>Si un iterador se utiliza sin bloque, entonces retorna un Enumerator</p>
<pre><code class="ruby">
a = [1,2,3].each

a.next

</code></pre>
</section>
<section>

<h2>El método loop</h2>

<ul>
<li>Ejecuta el código que se encuentra dentro del bloque</li>
<li>Se puede salir con break cuando se cumple una condición</li>
<li>Si hay iteradores, <code>loop</code> terminará cuando el Enumerator se quede sin valores</li>
</ul>

<h3>Ejemplos</h3>
<pre><code class="ruby">loop { puts "Hola" }

i=0
loop do
  puts i += 1
  break if i &gt;= 10
end

short_enum = [1, 2, 3].to_enum
long_enum = ('a'..'z').to_enum
loop { puts "#{short_enum.next} - #{long_enum.next}" }
</code></pre>
</section>
<section>

<h2>Usando Enumerator como objeto</h2>

<p>Sabemos que es posible usar <code>each_with_index</code> en <code>Array</code></p>
<pre><code class="ruby">result = []
[ 'a', 'b', 'c' ].each_with_index do |item, index| 
  result &lt;&lt; [item, index] 
end
</code></pre>
<p>¿Y si queremos hacer lo mismo con un <code>String</code>?</p>

<ul>
<li>No existe <code>each_with_index</code> en <code>String</code>
</li>
<li>Pero sí existe <code>each_char</code> que es como <code>each</code> de <code>Array</code> pero sobre cada
caracter del string

<ul>
<li>Si no enviamos un bloque, retornará un <code>Enumerator</code>
</li>
</ul>
</li>
<li>La interfaz <code>Enumerable</code> define el método <code>each_with_index</code>
</li>
</ul>

</section>
<section>

<h2>El código con String quedaría</h2>
<pre><code class="ruby">result = []
"cat".each_char.each_with_index do |item, index| 
    result &lt;&lt; [item, index] 
end
# Aun más simple:
result = []
"cat".each_char.with_index do |item, index| 
    result &lt;&lt; [item, index] 
end
</code></pre>
</section>
<section>

<h2>Enumerator como generadores</h2>

<ul>
<li>Podemos crear objetos enumerator explícitamente en vez de hacerlo a partir de
una colección</li>
<li>Para ello es necesario utilizar un bloque en la creación

<ul>
<li>El código del bloque se usará por el objeto Enumerator cada vez que el
programa principal le solicite un nuevo valor</li>
<li>Este bloque no se ejecutará como otros bloques dado que su ejecución
se disparará cada vez que se solicita el siguiente valor</li>
<li>La ejecución del bloque se pausa y vuelve al programa principal cuando se
encuentra <code>yield</code>
</li>
<li>Cuando se solicita el siguiente valor, el código del bloque continúa a
partir de la línea siguiente al <code>yield</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Enumerator como generadores</h2>

<p>Los enumerators creados de esta forma permiten generar <strong>secuencias infinitas</strong> </p>
<pre><code class="ruby">fibonacci = Enumerator.new do |caller|
  i1, i2 = 1, 1
  loop do
    caller.yield i1
    i1, i2 = i2, i1+i2
  end
end

6.times { puts fibonacci.next }
</code></pre>
<p>Como <code>Enumerator</code> es <code>Enumerable</code> sería posible:</p>
<pre><code class="ruby">
fibonacci.first(1000).last

</code></pre>
</section>
<section>

<h2>¡Hay que tener cuidado!</h2>

<ul>
<li>Cuidado con los enumerators que generan listas infinitas</li>
<li>Los metodos comunes de los enumeradores como <code>count</code> y <code>select</code> tratarán de
leer todos los elementos antes de retornar un valor

<ul>
<li>Podemos escribir la versión de <code>select</code> adecuada a nuestra lista
infinita</li>
</ul>
</li>
</ul>
<pre><code class="ruby">def infinite_select(enum, &amp;block)
  Enumerator.new do |caller|
    enum.each do |value|
      caller.yield(value) if block.call(value)
    end
  end
end

p infinite_select(fibonacci) {|val| val % 2 == 0}.first(5)
</code></pre>
</section>
<section>

<h2>Haciendo algo más conveniente</h2>

<ul>
<li>Podemos escribir filtros como <code>infinite_select</code> directamente en la clase
<code>Enumerator</code>
</li>
<li>Esto nos permitirá encadenar filtros:</li>
</ul>
<pre><code class="ruby">class Enumerator
  def infinite_select(&amp;block)
    Enumerator.new do |caller|
      self.each do |value|
        caller.yield(value) if block.call(value)
      end
    end
  end
end

p fibonacci.
  infinite_select {|val| val % 2 == 0}.
  infinite_select {|val| val.to_s =~ /13\d$/ }.
  first(2)
</code></pre>
</section>
<section>

<h2>Bloques como transacciones</h2>

<ul>
<li>Podemos usar bloques para definir código que debe ejecutarse bajo ciertas
condiciones transaccionales.</li>
<li>Por ejemplo:

<ul>
<li>Abrir un archivo</li>
<li>Procesarlo</li>
<li>Cerrarlo</li>
</ul>
</li>
<li>Si bien esto podemos hacerlo secuencialmente, utilizando bloques simplificamos
mucho </li>
</ul>
<pre><code class="ruby">class File
  def self.open_and_process(*args)
    f = File.open(*args)
    yield f
    f.close()
  end
end
</code></pre>
</section>
<section>

<h2>Analizamos un poco...</h2>

<ul>
<li>El método de clase implementado fue desarrollado para que entienda los mismos
parámetros que <code>File.open</code> </li>
<li>Para ello, lo que hicimos es pasar los parámetros tal cual se enviaron a
<code>File.open</code>

<ul>
<li>Esto se logra definiendo como argumento al método <code>*args</code> que significa:
<em>tomar todos los argumentos enviados al método actual y colocarlos en un
arreglo llamado args</em>
</li>
<li>Luego llamamos a <code>File.open(*args)</code>. Utilizar *args vuelve a expandir los
elementos del arreglo a parámetros individuales</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Una versión más completa de my_open</h2>
<pre><code class="ruby">class File
  def self.my_open(*args)
    result = file = File.new(*args)
    if block_given?
      result = yield file
      file.close
    end
    return result
  end
end
</code></pre>
<ul>
<li>Podría suceder un error en el procesamiento</li>
<li>Para asegurar el cierre del archivo, se deben usar excepciones, que veremos 
más adelante</li>
</ul>

<p><small class="fragment">
<em>Esta técnica es tan útil, que <code>File.open</code> ya lo implementa.  Además de usar <code>File.open</code>
para abrir un archivo, podemos usarlo para directamente procesarlo como lo hacíamos
con <code>open_and_process</code></em>
</small></p>

</section>
<section>

<h2>Los bloques pueden ser objetos</h2>

<ul>
<li>Anteriormente mencionamos que los bloques son como un parámetro
adicional pasado a un método</li>
<li>Podremos forzar bloques como parámetros explícitos

<ul>
<li>Utilizando &amp; en el último parámetro, Ruby buscará el codigo
de un bloque cuando el método es invocado</li>
<li>Este parámetro podrá utilizarse como cualquier otro</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class ProcExample
  def pass_in_block(&amp;action)
    @stored_proc = action
  end
  def use_proc(parameter)
    @stored_proc.call(parameter)
  end
end

eg = ProcExample.new
eg.pass_in_block { |param| puts "The parameter is #{param}" }
eg.use_proc(99)
</code></pre>
</section>
<section>

<h2>Avanzando un poco más...</h2>

<ul>
<li>Vemos que <code>call</code> invoca la ejecución del bloque </li>
<li>Muchos programas utilizan esta idea para implementar <strong>callbacks</strong>
</li>
<li>¿Qué pasaría si retornamos el bloque?</li>
</ul>
<pre><code class="ruby">def create_block_object(&amp;block)
  block
end

bo = create_block_object do |param| 
  puts "You called me with #{param}"
end
bo.call 99
bo.call "cat"
</code></pre>
</section>
<section>

<h2>Proc y lambda</h2>

<ul>
<li>Devolver un bloque es tan útil que en Ruby hay dos formas de hacerlo:

<ul>
<li>
<code>lamda</code> y <code>Proc.new</code> toman un bloque y retornan un objeto</li>
<li>El objeto retornado es de la clase <code>Proc</code>
</li>
<li>La diferencia entre <code>lambda</code> y <code>Proc.new</code> la veremos más adelante, pero ya
hemos mencionado que <code>lambda</code> controla los parámetros que requiere el
bloque, mientras que <code>Proc</code> no lo hace</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Los bloques pueden ser Closures</h2>

<ul>
<li>Recordamos haber mencionado que los bloques pueden utilizar variables que
están dentro del alcance del bloque</li>
<li>Veremos ahora un uso diferente de un bloque haciendo esto</li>
</ul>
<pre><code class="ruby">def n_times(thing)
  lambda {|n| thing * n }
end
p1 = n_times(10)
p1.call(3)
p1.call(4)
p2 = n_times("Hola ")
p2.call(3)
</code></pre>
</section>
<section>

<h2>¿Qué es un Closure?</h2>

<ul>
<li>El método <code>n_times</code> referencia el parámetro <code>thing</code> que es usado por el bloque</li>
<li>Aunque en las llamadas a <code>call</code> (y por ende en la ejecución del bloque) el 
parámetro <code>thing</code> está fuera del alcance, el parámetro se mantiene accesible
dentro del bloque</li>
<li>Esto es un closure:

<ul>
<li>Variables en el alcance cercano que son referenciadas por el bloque se
mantienen accesibles por la vida del bloque y la vida del objeto Proc creado
para este bloque</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Otro ejemplo de closure</h2>
<pre><code class="ruby">def what_do_i_do?
  value = 1
  lambda { value += value }
end

let_me_see = what_do_i_do?
let_me_see.call
let_me_see.call
</code></pre>
</section>
<section>

<h2>Notación alternativa</h2>

<p>A partir de ruby 1.9 </p>
<pre><code class="ruby">lambda { |params| ... }

# es equivalente a

-&gt;params { ... }

# Y con parámetros

proc1 = -&gt; arg {puts "proc1:#{arg}" }
proc2 = -&gt; arg1, arg2 {puts "proc2:#{arg1} y #{arg2}" }
proc3 = -&gt;(arg1, arg2) {puts "proc3:#{arg1} y #{arg2}" }

proc1.call "ant"
proc2.call "bee", "cat"
proc3.call "dog", "elk"
</code></pre>
</section>
<section>

<h2>Locas ideas</h2>

<p>Reimplementamos un while usando bloques</p>
<pre><code class="ruby">def my_while(cond, &amp;body)
  while cond.call
    body.call
  end
end

a = 0
my_while -&gt; { a &lt; 3 } do
  puts a
  a += 1
end
</code></pre>
</section>
<section>

<h2>Lista de parámetros a un bloque</h2>

<ul>
<li>Los argumentos a un bloque podrán ser:

<ul>
<li>Argumentos splat</li>
<li>Inicializados con un valor por defecto</li>
<li>Bloques como parámetro (usando &amp;)</li>
</ul>
</li>
</ul>
<pre><code class="ruby">proc1 = lambda do |a, *b, &amp;block|
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc1.call(1, 2, 3, 4) { puts "in block1" }

proc2 = -&gt; a, *b, &amp;block do
  puts "a = #{a.inspect}"
  puts "b = #{b.inspect}"
  block.call
end
proc2.call(1, 2, 3, 4) { puts "in block2" }
</code></pre>
</section>
<section>

<h2>El símbolo usado como bloque</h2>

<p>Para entender por qué funciona:</p>
<pre><code class="ruby">[1,2,3].inject &amp;:+
</code></pre>
<ul>
<li>Analizando qué es lo que sucede, veamos el siguiente ejemplo</li>
</ul>
<pre><code class="ruby">o = Object.new
[1,2,3].inject &amp;o
# Esto da un error: TypeError: wrong argument type Object (expected Proc)
</code></pre>
<p>Que se soluciona con:</p>
<pre><code class="ruby">class Object
  def to_proc
    Proc.new {}
  end
end
</code></pre>
</section>
<section>

<h2>El símbolo usado como bloque</h2>

<p>Analizando entonces lo que sucedió inferimos que la clase <code>Symbol</code> implementa
<code>#to_proc</code> de la siguiente forma:</p>
<pre><code class="ruby">class Symbol
  def to_proc
    lambda { |obj| obj.send(self) }
  end
end
</code></pre>
<p><small>
El ejemplo <code>[1,2,3].map &amp;:to_s</code> ¡funciona perfecto!
<br>
<strong>Pero no funciona <code>[1,2,3].inject &amp;:+</code></strong>
</small></p>

</section>
<section>

<h2>El símbolo usado como bloque</h2>

<p>Tratamos de solucionar la implementación anterior:</p>
<pre><code class="ruby">class Symbol
  def to_proc
    lambda { |obj, args| obj.send(self, *args) }
  end
end
</code></pre>
<p><small>
El ejemplo <code>[1,2,3].inject &amp;:+</code> ¡funciona pefecto!
<br>
<strong>Pero no funciona <code>[1,2,3].map &amp;:to_s</code></strong>
</small></p>

</section>
<section>

<h2>El símbolo usado como bloque</h2>

<p>La solución a ambos problemas:</p>
<pre><code class="ruby">class Symbol
  def to_proc
    lambda { |obj, args=nil| obj.send(self, *args) }
  end
end
</code></pre>
</section>
</section>

<section>
<section>

<h1>Herencia, módulos y mixins</h1>

</section>
<section>

<h1>Introducción</h1>

<ul>
<li>Uno de los principios aceptados sobre buen diseño es la eliminación de
duplicados innecesarios</li>
<li>Trataremos de lograr que cada concepto en nuestra aplicación sea expresado sólo
una vez en el código</li>
</ul>

</section>
<section>

<h2>Herencia</h2>

<ul>
<li>Permite crear clases que son un refinamiento o especialización de otra clase</li>
<li>A esta clase se la llama <em>subclase</em> de la original</li>
<li>A la clase original se la llama <em>superclase</em> de la subclase</li>
<li>También se utilizan los términos: clase padre y clase hija</li>
<li>El mecanismo de herencia es simple:

<ul>
<li>Los hijos heredan todas las capacidades de la clase padre</li>
<li>Todos los métodos de instancia y clase de la clase padre estarán disponibles en los
hijos</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de herencia</h2>
<pre><code class="ruby">class Parent
  def say_hello
    puts "Hello from #{self}"
  end
end

p = Parent.new
p.say_hello

# Subclass the parent...
class Child &lt; Parent
end

c = Child.new
c.say_hello
</code></pre>
</section>
<section>

<h2>Conociendo la herencia</h2>

<p>El método <code>superclass</code> devuelve la clase padre</p>
<pre><code class="ruby">puts "The superclass of Child is #{Child.superclass}"
puts "The superclass of Parent is #{Parent.superclass}"
puts "The superclass of Object is #{Object.superclass}"
</code></pre>
<ul>
<li>Si no se define superclase, Ruby asume <code>Object</code>

<ul>
<li>
<code>to_s</code> está definido aquí</li>
</ul>
</li>
<li>
<code>BasicObject</code> es utilizado en metaprogramación. 

<ul>
<li>Su padre es <code>nil</code>
</li>
<li>Es la raíz: todas las clases lo tendran como ancestro </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Veamos un ejemplo completo</h2>

<ul>
<li>
<code>GServer</code> es un servidor TCP/IP genérico</li>
<li>Agregaremos funcionalidad básica a nuestro servicio subclaseando GServer

<ul>
<li>El servicio mostrará las últimas lineas del archivo de logs del sistema:
<code>/var/log/syslog</code>
</li>
</ul>
</li>
<li>GServer manipula todo lo relacionado a sockets TCP. 

<ul>
<li>Nosotros sólo indicaremos el puerto en la inicialización</li>
<li>Cuando un cliente se conecte, el objeto GServer invocará al método <code>serve</code>
</li>
<li>GServer no hace nada en el método que implementa <code>serve</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>LogServer</h2>
<pre><code class="ruby">require 'gserver'
class LogServer &lt; GServer

  def initialize
    super(12345)
  end

  def serve(client)
    client.puts get_end_of_log_file
  end

  private
    def get_end_of_log_file
      File.open("/var/log/syslog") do |log|
        # back up 1000 characters from end
        log.seek(-1000, IO::SEEK_END)
        # ignore partial line
        log.gets
        # and return rest
        log.read
      end
    end
end

server = LogServer.new
server.start.join
</code></pre>
<p><small>
<code>GServer</code> ya no es parte del ruby core. Debe instalarse con gem install gserver
<br>
<a href="images/samples/08/log_server.zip">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>¿Cómo hemos usado la herencia?</h2>

<ul>
<li>
<code>LogServer</code> hereda de <code>GServer</code>
</li>
<li>Esto indica que: 

<ul>
<li>LogServer es un GServer, compartiendo toda su funcionalidad</li>
<li>LogServer es una especialización</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Cómo hemos usado la herencia?</h2>

<ul>
<li>La primer especialización es con <code>initialize</code>

<ul>
<li>Se fuerza el puerto a 12345</li>
<li>El puerto es un parámetro del constructor de GServer</li>
<li>Para invocar el método constructor del padre, utilizamos <code>super</code>
</li>
<li>Cando se invoca <code>super</code>, Ruby envía el método a la clase padre del objeto
actual, indicando que invoque el mismo método que se está ejecutando en el
hijo. Se enviarán los parámetros que fueron pasados a <code>super</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Cómo hemos usado la herencia?</h2>

<ul>
<li>La implementación de <code>serve</code> es algo común en OO

<ul>
<li>El padre asume que será subclaseado invocando un método que asume será
implementado por sus hijos</li>
<li>Esto permite a la clase padre implementar lo más pesado del procesamiento y
delegar a los hijos mediante callbacks funcionalidad extra</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Cómo hemos usado la herencia?</h2>

<ul>
<li><p>Veremos más adelante que esta práctica <strong><em>muy común en OO</em></strong> no la convierte en <strong><em>un buen diseño</em></strong></p></li>
<li><p>En su lugar veremos <strong><em>mixins</em></strong></p></li>
<li><p>Pero para explicar mixins, antes tenemos que explicar <strong><em>módulos</em></strong></p></li>
</ul>

</section>
<section>

<h1>Modulos</h1>

</section>
<section>

<h2>Modulos</h2>

<ul>
<li>Los módulos son una forma de agrupar métodos, clases y constantes. </li>
<li>Proveen dos beneficios:

<ul>
<li>Proveen <strong>namespaces</strong> y previenen el solapamiento de nombres</li>
<li>Son la clave de los <strong>mixins</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Namespaces</h2>

<ul>
<li>A medida que los programas crecen, surge código reusables</li>
<li>Es así como aparecen las librerías</li>
<li>Deseamos agrupar en archivos diferentes estas rutinas de forma tal
de poder reusarlas en programas distintos</li>
<li>Generalmente estas rutinas pertenecerán a una clase, o grupos de clases
interrelacionadas, que podríamos disponer en un único archivo

<ul>
<li>Sin embargo, a veces queremos agrupar cosas que no necesariamente forman una
clase</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Namespaces</h2>

<ul>
<li>Como una primer idea, podríamos pensar en disponer todos los archivos que
componen nuestra librería y luego cargar el archivo en nuestro programa cuando
lo necesite</li>
<li>Esta idea tiene un problema si definimos funciones con nombres que son iguales 
a los de otra librería</li>
</ul>

</section>
<section>

<h2>La solución</h2>
<pre><code class="ruby">module Trig
  PI = 3.141592654
  def self.sin(x)
  # ..
  end
  def self.cos(x)
  # ..
  end
end
module Moral
  VERY_BAD = 0
  BAD = 1
  def self.sin(badness)
  # ...
  end
end
</code></pre>
</section>
<section>

<h2>¿Como se usa?</h2>
<pre><code class="ruby">y = Trig.sin(Trig::PI/4)
wrongdoing = Moral.sin(Moral::VERY_BAD)
</code></pre>
<ul>
<li>Así como en los métodos de clase, se invocan los métodos de un módulo
precediéndolos con el nombre del módulo y un punto</li>
<li>Las constantes se referencian con el nombre del módulo y doble dos puntos (::)</li>
</ul>

</section>
<section>

<h2>Mixins</h2>

<ul>
<li>En el ejemplo reciente, definimos métodos del módulo que prefijábamos con el
nombre del módulo: <code>self.cos</code>
</li>
<li>La primer asociación es que los métodos de un módulo son como métodos de clase</li>
<li>La siguiente pregunta sería: <em>Si los métodos del módulo son como métodos de
clase, qué serían los métodos de instancia de un módulo?</em>
</li>
</ul>

</section>
<section>

<h2>Mixins</h2>

<ul>
<li>Un módulo <strong>no puede tener instancias</strong> porque no es una clase</li>
<li>Podremos <strong>incluir</strong> un módulo a una definición de clase</li>
<li>Cuando esto sucede, los métodos de instancia definidos en el módulo son
incluidos como métodos de instancia de la clase. Se <strong>mezclan</strong> (mixed in)</li>
<li>En efecto, los módulos mixins se comportan como superclases</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="ruby">module Debug
  def who_am_i?
    "#{self.class.name}(\##{self.object_id}):#{self.to_s}"
  end
end

class Phonograph
  include Debug
  def initialize(n); @n=n; end
  def to_s; @n; end
end

class EightTrack
  include Debug
  def initialize(n); @n=n; end
  def to_s; @n; end
end

ph = Phonograph.new("West End Blues")
et = EightTrack.new("Surrealistic Pillow")
ph.who_am_i?
et.who_am_i?
</code></pre>
</section>
<section>

<h2>El uso de include</h2>

<ul>
<li>El <code>include</code> en Ruby agrega una referencia al módulo que agregará nuevos
métodos a nuestra clase</li>
<li>Si varias clases incluyen el mismo módulo, todas tendran referencias al mismo</li>
<li>Si modificamos el módulo durante la ejecución del programa, todas las clases
que incluían el módulo tomarán los cambios automáticamente</li>
</ul>

</section>
<section>

<h2>El potencial</h2>

<ul>
<li>El potencial real de los mixins se obtiene cuando el código de un mixin
interactúa con código de una clase que lo utiliza</li>
<li>Analizamos el caso de un mixin que es parte de la librería estándar de Ruby,
<code>Comparable</code>

<ul>
<li>Agrega los operadores de comparación: <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>
</li>
<li>Agrega el método <code>between?</code>
</li>
<li>Asume que la clase que utilice este mixin, implementará el método <code>&lt;=&gt;</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Lo probamos con la clase Person</h2>
<pre><code class="ruby">class Person
  include Comparable
  attr_reader :name
  def initialize(name)
    @name = name
  end
  def to_s
    "#{@name}"
  end
  def &lt;=&gt;(other)
    self.name &lt;=&gt; other.name
  end
end
p1 = Person.new("Matz")
p2 = Person.new("Guido")
p3 = Person.new("Larry")
[p1, p2, p3].sort
</code></pre>
</section>
<section>

<h2>Iteradores y el módulo Enumerable</h2>

<ul>
<li>Si queremos que nuestra clase entienda los iteradores <code>each</code>, <code>include?</code>,
<code>find_all?</code>

<ul>
<li>Incluimos el módulo <code>Enumerable</code>
</li>
<li>Implementamos el iterador <code>each</code>
</li>
</ul>
</li>
<li>Si además los elementos de nuestra colección implementan <code>&lt;=&gt;</code> entonces
dispondremos de: 

<ul>
<li><code>min</code></li>
<li>
<code>max</code> </li>
<li>
<code>sort</code> </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Composición de módulos</h2>

<p>Creamos nuestra clase Enumerable</p>
<pre><code class="ruby">class VowelFinder
  include Enumerable
  def initialize(string)
    @string = string
  end
  def each
    @string.scan(/[aeiou]/i) do |vowel|
      yield vowel
    end
  end
end
vf = VowelFinder.new "El murcielago tiene todas"
vf.inject(:+)
</code></pre>
<p>Lo mismo hacemos con otras colecciones</p>
<pre><code class="ruby">[ 1, 2, 3, 4, 5 ].inject(:+)
( 'a'..'m').inject(:+)
</code></pre>
</section>
<section>

<h2>Creamos el módulo Summable</h2>
<pre><code class="ruby">module Summable
  def sum
    inject(:+)
  end
end
</code></pre>
<p>Lo aplicamos a las clases del ejemplo</p>
<pre><code class="ruby">class Array; include Summable; end
class Range; include Summable; end
class VowelFinder; include Summable; end

[ 1, 2, 3, 4, 5 ].sum
('a'..'m').sum
vf.sum
</code></pre>
</section>
<section>

<h2>Variables de instancia en mixins</h2>

<ul>
<li>En ruby las variables de instancia se crean cuando se nombran por
primera vez </li>
<li>Esto significa que un Mixin podrá crear variables de instancia si las nombra
por primera vez en la clase</li>
</ul>
<pre><code class="ruby">module Observable
  def observers
    @observer_list ||= []
  end
  def add_observer(obj)
    observers &lt;&lt; obj
  end
  def notify_observers
    observers.each {|o| o.update }
  end
end
</code></pre>
</section>
<section>

<h2>Variables de instancia en mixins</h2>

<ul>
<li>Sin embargo, este uso es <strong>riesgoso</strong>
</li>
<li>Los nombres de las variables pueden colisionar con otro nombre de la clase u
otros módulos.</li>
<li>Un programa que caiga en este escenario dará resultados erróneos y
difíciles de rastrear</li>
</ul>

<h3>Solución</h3>

<ul>
<li>La mayoría de las veces, los modulos Mixins no usan variables de instancia,
sino accessors</li>
<li>En caso de necesitarlo, utilizar nombres que se prefijen con el nombre del
módulo por ejemplo</li>
</ul>

</section>
<section>

<h2>Resolución de nombres ambiguos de métodos</h2>

<ul>
<li>
<em>¿Cómo se resuelve el nombre de un método que es el mismo en la clase, que 
es implementado en la superclase y además definido en uno o varios módulos 
incluidos?</em>

<ul>
<li>Primero se busca si la clase del objeto lo implementa</li>
<li>Luego en los mixins incluidos por la clase. <em>Si tiene varios módulos, el
último será el considerado</em>
</li>
<li>Luego en la superclase</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Caso 1</h2>
<pre><code class="ruby">module MyModule
  def test
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child &lt; Parent
  include MyModule
  def test
    "Child"
  end
end

t = Child.new
p t.test
</code></pre>
</section>
<section>

<h2>Caso 2</h2>
<pre><code class="ruby">module MyModule
  def test
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child &lt; Parent
  include MyModule
end

t = Child.new
p t.test
</code></pre>
</section>
<section>

<h2>Caso 3</h2>
<pre><code class="ruby">module MyModule
  def test1
    "Module"
  end
end

class Parent
  def test
    "Parent"
  end
end

class Child &lt; Parent
  include MyModule
end

t = Child.new
p t.test
</code></pre>
</section>
<section>

<h2>Herencia, Mixins y Diseño</h2>

<ul>
<li>Herencia y Mixins ambos permiten escribir código en un único lugar</li>
<li>
<em>¿Cuándo usar cada uno?</em>

<ul>
<li>El uso de herencia debe aplicarse cuando se cumple la propiedade <strong>es un</strong>
</li>
<li>La herencia puede asociarse con la creación de clases, que sería como 
agregar nuevos tipos al lenguaje</li>
<li>Al usar herencia <strong>deberíamos en todo momento poder reemplazar un objeto de
la superclase por un objeto de la subclase</strong>. <em>Los hijos deben
hacer honor a los contratos asumidos por el padre</em>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Herencia, Mixins y Diseño</h2>

<ul>
<li>La realidad dice que el uso de herencia no siempre se usa para representar la
relación <em>es un</em>

<ul>
<li>En realidad muchas veces se utiliza <strong>mal</strong> en situaciones que representan 
una relación de <em>posee un</em> o <em>utiliza un</em>
</li>
<li>El mundo se crea a partir de <strong>composiciones</strong> más que de restricciones de
herencia estrictas</li>
</ul>
</li>
<li>Dado que la herencia era el único mecanismo disponible para compartir código,
nos volvimos <strong>vagos</strong> y empezamos a afirmar cosas como: <em>Que una Persona</em> <strong><em>es un</em></strong> <em>DatabaseWrapper</em>

<ul>
<li>Pero una persona no es un DatabaseWrapper</li>
<li>Una Persona <strong>usa</strong> un DatabaseWrapper para proveer persistencia</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Herencia, Mixins y Diseño</h2>

<ul>
<li>La herencia además representa un gran acomplamiento entre dos componentes.
Cambiar la herencia sería algo complejo en cualquier programa mediano</li>
<li>
<strong>Debemos utilizar composición cada vez que encontramos una relación:</strong> A
<em>usa</em> B o A <em>tiene un</em> B

<ul>
<li>Nuestra persona no sería un DatabseWrapper, incluiría la funcionalidad para
persistir y recuperar una persona</li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<h1>Tipos estándar</h1>

</section>
<section>

<h2>Números</h2>

<ul>
<li>Los números que soporta Ruby son: 

<ul>
<li>Enteros</li>
<li>Punto flotante</li>
<li>Racionales</li>
<li>Complejos</li>
</ul>
</li>
<li>Los enteros se manejan internamente por Ruby como binarios.

<ul>
<li>Se representan con Fixnum en el rango de (-2^30..2^30-1 o -2^62..2^62-1)</li>
<li>Fuera del rango anterior, Ruby utiliza Bignum</li>
<li>El proceso es transparente </li>
</ul>
</li>
<li>Es importante considerar que los strings no se convierten automáticamente a
enteros: <code>'1' + '2' =&gt; '12'</code>
</li>
</ul>

</section>
<section>

<h2>¿Cómo interactúan?</h2>
<pre><code class="ruby">1 + 2               # =&gt; 3
1 + 2.0             # =&gt; 3.0
1.0 + 2             # =&gt; 3.0
1.0 + Complex(1,2)  # =&gt; (2.0,2i)
1 + Rational(2,3)   # =&gt; (5/3)
1.0 + Rational(2,3) # =&gt; 1.66666666666665

# Y cuando se divide:

1.0/2               # =&gt; 0.5
1/2.0               # =&gt; 0.5
1/2                 # =&gt; 0
</code></pre>
<p>Probar la división requiriendo <code>mathn</code></p>

</section>
<section>

<h2>Strings y el encoding</h2>

<ul>
<li>A partir de ruby 1.9, cada string tiene asociada una codificación</li>
<li>Por defecto, la codificación asociada a un literal string dependerá de la 
codificación del archivo fuente donde se especificó

<ul>
<li>Sin especificar la codificación de un fuente ruby, se asume: <code>US-ASCII</code> en
1.9 y <code>UTF-8</code> a partir de ruby 2</li>
<li>Cambiamos la codificación de un fuente agregando en la primer línea un
comentario <code>#encoding: xxxx</code> donde xxx corresponde a la codificación</li>
</ul>
</li>
</ul>
<pre><code class="ruby">#encoding: iso-8859-1
txt = "dog"
puts "Encoding of #{txt.inspect} is #{txt.encoding}"
</code></pre>
</section>
<section>

<h2>Usando rangos como condiciones</h2>

<ul>
<li>Generalmente usamos rangos como secuencias y dependiendo del tipo del rango
podíamos pedir: <code>min</code>, <code>max</code>, <code>include</code>, etc</li>
<li>Ahora veremos una forma de utilizar los rangos como condiciones, de forma tal
que el objeto rango mantendrá el estado de las comparaciones que macheen desde
un valor (el inicial del rango) hasta el final (del rango)</li>
</ul>

<h3>Dos ejemplos</h3>
<pre><code class="ruby">100.times {|x| p x if x==50 .. x==55 }

while line = gets
  puts line if line =~ /start/ .. line =~ /end/
end
</code></pre>
</section>
<section>

<h2>Usando rangos como intervalos</h2>
<pre><code class="ruby">car_age = gets.to_f # let's assume it's 5.2
case car_age
  when 0...1
    puts "Mmm.. new car smell"
  when 1...3
    puts "Nice and new"
  when 3...6
    puts "Reliable but slightly dinged"
  when 6...10
    puts "Can be a struggle"
  when 10...30
    puts "Clunker"
  else
    puts "Vintage gem"
end
</code></pre>
</section>
<section>

<h2>Buscando el problema...</h2>
<pre><code class="ruby">car_age = gets.to_f # let's assume it's 5.2
case car_age
  when 0..0
    puts "Mmm.. new car smell"
  when 1..2
    puts "Nice and new"
  when 3..5
    puts "Reliable but slightly dinged"
  when 6..9
    puts "Can be a struggle"
  when 10..29
    puts "Clunker"
  else
    puts "Vintage gem"
end

</code></pre>
</section>
</section>

<section>
<section>

<h1>Los métodos</h1>

</section>
<section>

<h2>Definiendo un método</h2>

<ul>
<li>Los nombres de los métodos deben empezar con minúscula o underescore

<ul>
<li><em>No es error que el nombre comience con mayúsucla, el problema es que en la
invocación, Ruby tratará de interpretarlo como una constante, y por tanto
parsear la llamada en forma incorrecta. Por convención, los métodos que
comienzan con mayúscula se utilizan para conversiones de tipos</em></li>
</ul>
</li>
<li>Cuando retornamos un boolean, es prolijo que el método termine con <code>?</code>
</li>
<li>Aquellos métodos <em>peligrosos</em> deben terminar con <code>!</code>
</li>
<li>Los métodos que aparecen a la izquierda de una asignación terminan con <code>=</code>
</li>
</ul>

</section>
<section>

<h2>Argumentos</h2>

<ul>
<li>Los parámtros a un método se escriben como una lista de variables entre
paréntesis

<ul>
<li><em>Los paréntesis pueden omitirse; por convensión se usarán paréntesis cuando
el método tenga argumentos, y omitirlos cuando no</em></li>
</ul>
</li>
<li>Es posible definir valores por defecto para los argumentos

<ul>
<li><em>Incluso usando como valor un parámetro anterior</em></li>
</ul>
</li>
</ul>
<pre><code class="ruby">def concat(a="a", b="b")
  "#{a},#{b}"
end

def surround(word, pad_width=word.length/2)
"[" * pad_width + word + "]" * pad_width
end
</code></pre>
</section>
<section>

<h2>Argumentos variables</h2>

<ul>
<li>Usando un <code>*</code> antes del nombre del argumento, luego de los parámetros normales logramos este efecto

<ul>
<li>A partir de Ruby 1.9, es posible definir el argumento variable en cualquier
posición. Lo importante es no tener más de uno</li>
</ul>
</li>
<li>A esta técnica se la suele llamar: <em>splatting an argument</em> </li>
</ul>
<pre><code class="ruby">def varargs(arg1, *rest)
  "arg1=#{arg1}. rest=#{rest.inspect}"
end
</code></pre>
</section>
<section>

<h2>Usos de splat</h2>

<ul>
<li>Es común que se utilice splat en una subclase para pasar los parámetros a la
superclase usando <code>super</code>

<ul>
<li>Si no se especifican parámetros a <code>super</code>, entonces se invoca el método del
padre con todos los argumentos que se hayan recibido</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class Child &lt; Parent
  def do_something(*not_used)
    # our processing
    super
  end
end
</code></pre>
<p>O en forma similar</p>
<pre><code class="ruby">class Child &lt; Parent
  def do_something(*)
    # our processing
    super
  end
end
</code></pre>
</section>
<section>

<h2>Retornando valores</h2>

<ul>
<li>Los métodos siempre retornan un valor aunque el mismo no sea utilizado</li>
<li>Podemos usar <code>return</code> para forzar la salida

<ul>
<li>Si se envían varios parámetros a <code>return</code> se retorna un arreglo</li>
<li>El caso anterior se puede usar en asignaciones en paralelo</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Expandiendo collecciones en llamadas a métodos</h2>

<ul>
<li>Es la idea inversa a la explicación de splat previa</li>
</ul>
<pre><code class="ruby">def five(a, b, c, d, e)
  "I was passed #{a} #{b} #{c} #{d} #{e}"
end

five(1, 2, 3, 4, 5 )
five(1, 2, 3, *['a', 'b'])
five(*['a', 'b'], 1, 2, 3)
five(*(10..14))
five(*[1,2], 3, *(4..5))
</code></pre>
</section>
<section>

<h2>Haciendo más dinámicos los bloques</h2>

<p>Al igual que en el caso anterior de splat, podemos necesitar especificar que
uno de los parámetros a un método es un bloque</p>
<pre><code class="ruby">## En vez de 
(1..10).collect { |x| x*2}.join(',')

## Podemos usar
b = -&gt; x { x*2}
(1..10).collect(&amp;b).join ','
</code></pre>
</section>
<section>

<h2>Argumentos como Hash</h2>

<ul>
<li>Hasta Ruby 1.9 no existía la posibilidad de usar <em>keyword arguments</em> 

<ul>
<li>En vez de especificar los parámetros en el orden en que se definieron, es posible
especificar qué valor tomará cada parámetro indicando el hecho con el nombre
del argumento y su valor</li>
</ul>
</li>
<li>Hasta que Ruby 1.9 se utilizaba Hash en su reemplazo para obtener el mismo
resultado</li>
</ul>

</section>
<section>

<h2>Ejemplo con Hash</h2>
<pre><code class="ruby">class SongList
  def search(name, params)
  # ...
  end
end
list.search(:titles,
            { :genre              =&gt; "jazz",
              :duration_less_than =&gt; 270
            })
</code></pre>
</section>
<section>

<h2>Argumentos como Hash</h2>

<ul>
<li>En el ejemplo anterior el primer parámetro indica qué atributo retornar
mientras que el segundo es un hash con el criterio de búsqueda</li>
<li>Lo incómodo del ejemplo es la necesidad de usar <code>{}</code>, además de la posible
confusión con la posibilidad de que se esté indicando un bloque</li>
<li>Ruby ofrece una solución: puede usarse <code>clave =&gt; valor</code> en la lista de
argumentos siempre que:

<ul>
<li>Sea luego de los argumentos <em>normales</em>
</li>
<li>Antes de un splat y bloque</li>
<li>Ya no es necesario usar llaves</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo con hash</h2>
<pre><code class="ruby"># Ruby &lt;= 1.9
list.search(:titles,
            :genre              =&gt; 'jazz',
            :duration_less_than =&gt; 270)

# Ruby &gt;= 1.9
list.search(:titles, genre: 'jazz', duration_less_than: 270)
</code></pre>
</section>
<section>

<h2>Keyword arguments: solo Ruby 2.0</h2>

<p>Asumimos un supuesto método <code>log</code></p>
<pre><code class="ruby">def log(msg, level: "ERROR", time: Time.now)
  puts "#{ time.ctime } [#{ level }] #{ msg }"
end

## En Ruby 1.9 teníamos que:
def log(msg, opt = {})
  level = opt[:level] || "ERROR"
  time  = opt[:time]  || Time.now
  puts "#{ time.ctime } [#{ level }] #{ msg }"
end

log("Hello!", level: "INFO")
</code></pre>
</section>
<section>

<h2>Keyword arguments: solo Ruby 2.0</h2>

<ul>
<li>Las cosas parecen simples de reproducir con hashes, pero todo se complica un poco si sucede que:

<ul>
<li>Queremos usar keyword arguments con splat</li>
<li>Lanzar excepciones cuando un argumento no es conocido</li>
</ul>
</li>
</ul>

<p>Caeríamos en:</p>
<pre><code class="ruby">def log(*msgs)
  opt = msgs.last.is_a?(Hash) ? msgs.pop : {}
  level = opt.key?(:level) ? opt.delete(:level) : "ERROR"
  time  = opt.key?(:time ) ? opt.delete(:time ) : Time.now
  raise "unknown keyword: #{ opt.keys.first }" if !opt.empty?
  msgs.each {|msg| puts "#{ time.ctime } [#{ level }] #{ msg }" }
end
</code></pre>
<p><em>Pero nos gustó preservar la primer versión del ejemplo</em></p>

</section>
<section>

<h2>Keyword arguments: solo Ruby 2.0</h2>

<p>Probamos los argumentos</p>
<pre><code class="ruby">log("Hello")
log("Hello!", level: "ERROR", time: Time.now)
</code></pre>
<p>Y si cambiamos el orden</p>
<pre><code class="ruby">log("Hello!", time: Time.now, level: "ERROR") 
log(level: "ERROR", time: Time.now, "Hello!")
</code></pre>
<p>Cuando enviamos un argumento no conocido</p>
<pre><code class="ruby">log("Hello!", date: Time.new) 
</code></pre>
</section>
<section>

<h2>Keyword arguments: solo Ruby 2.0</h2>

<ul>
<li>Si queremos evitar las excepciones 

<ul>
<li>Podemos usar <code>**</code> para explícitamente agrupar el resto de los keyword
arguments en un hash (como splat)</li>
</ul>
</li>
</ul>

<p>Veamos como quedaría</p>
<pre><code class="ruby">def log(msg, level: "ERROR", time: Time.now, **kwrest)
  puts "#{ time.ctime } [#{ level }] #{ msg }"
end

log("Hello!", date: Time.now) 
</code></pre>
</section>
<section>

<h2>Keyword arguments: solo Ruby 2.0</h2>

<p>Todos los casos</p>
<pre><code class="ruby">def f(a, b, c, m = 1, n = 1, *rest, x, y, z, k: 1, 
      **kwrest, &amp;blk)
  puts "a: %p" % a
  puts "b: %p" % b
  puts "c: %p" % c
  puts "m: %p" % m
  puts "n: %p" % n
  puts "rest: [%p]" % rest.join(',')
  puts "x: %p" % x
  puts "y: %p" % y
  puts "z: %p" % z
  puts "k: %p" % k
  puts "kwrest: %p" % kwrest
  puts "blk: %p" % blk
end

f("a", "b", "c", 2, 3, "foo", "bar", "baz", "x", 
  "y", "z", k: 42, u: "unknown") { }
</code></pre>
</section>
</section>

<section>
<section>

<h1>Expresiones</h1>

</section>
<section>

<h2>Operadores</h2>

<ul>
<li>Ya hemos usado los operadores +, -, *, /, etc</li>
<li>Estos operadores se implementan como llamadas a métodos</li>
</ul>
<pre><code class="ruby">a, b, c = 1, 2, 3
a * b + c
# O en forma similar
(a.*(b)).+(c)
</code></pre>
</section>
<section>

<h2>Operadores</h2>

<p>Podemos redefinirlos incluso</p>
<pre><code class="ruby">class Fixnum
  alias old_plus +
  def +(other)
    old_plus(other).succ
  end
end
</code></pre>
</section>
<section>

<h2>Operadores</h2>

<p>Otro ejemplo con <code>&lt;&lt;</code></p>
<pre><code class="ruby">class ScoreKeeper
  def initialize
    @total_score = 0
    @count = 0
  end

  def &lt;&lt;(score)
    @total_score += score
    @count += 1
    self
  end

  def average
    fail "No scores" if @count == 0
    Float(@total_score) / @count
  end
end

scores = ScoreKeeper.new
scores &lt;&lt; 10 &lt;&lt; 20 &lt;&lt; 40
puts "Average = #{scores.average}"
</code></pre>
</section>
<section>

<h2>Operadores</h2>

<p>Incluso con <code>[]</code></p>
<pre><code class="ruby">class SomeClass
  def []=(*params)
    value = params.pop
    puts "Indexed with #{params.join(', ')}"
    puts "value = #{value.inspect}"
  end
end

s = SomeClass.new
s[1] = 2
s['cat', 'dog'] = 'enemies'
</code></pre>
</section>
<section>

<h2>Expresiones de comando</h2>

<p>Podemos usar comillas: <strong>`</strong>  ó <code>%x</code> para indicar la ejecución de un comando en el
sistema operativo subyacente</p>
<pre><code class="ruby">`date`
`ls`.split[34]
%x{echo "Hello there"}
`ip address ls`.
  split("\n").
  select {|x| x =~ / inet / }.
  map do |x|
    x.scan(/((\d{1,3}\.?){4}\/(\d){1,2})/).flatten.shift 
  end
</code></pre>
</section>
<section>

<h2>Expresiones de asignacion</h2>

<p>Jugando con splat y asignación en paralelo</p>
<pre><code class="ruby">a, b, c, d, e = *(1..2), 3, *[4, 5] # a=1, b=2, c=3, d=4, e=5

a1, *b1 = 1, 2, 3                   # a1=1, b1=[2, 3]

a2, *b2 = 1                         # a2=1, b2=[]

*a3, b3 = 1, 2, 3, 4                # a3=[1, 2, 3], b3=4

c, *d, e = 1, 2, 3, 4               # c=1, d=[2,3], e=4

f, *g, h, i, j = 1, 2, 3, 4         # f=1, g=[], h=2, i=3, j=4
</code></pre>
</section>
<section>

<h2>And</h2>

<ul>
<li>El operador <code>&amp;&amp;</code> y el método <code>and</code> funcionan similar 

<ul>
<li>Retornan el primer valor si es falso, sino el segundo. Ambos son iguales 
salvo por la precedencia: <code>and</code> es de menor precedencia que <code>&amp;&amp;</code>
</li>
</ul>
</li>
</ul>
<pre><code class="ruby">nil &amp;&amp; 99    # =&gt; nil
false &amp;&amp; 99  # =&gt; false
"cat" &amp;&amp; 99  # =&gt; 99
a = (true and false)
a = true and false # Check a, Why??
</code></pre>
</section>
<section>

<h2>Or</h2>

<ul>
<li>El operador <code>||</code> y el método <code>or</code> funcionan similar 

<ul>
<li>Retornan el primer valor si es verdadero, sino el segundo. Ambos son iguales 
salvo por la precedencia <code>or</code> es de menor precedencia que <code>||</code>
</li>
</ul>
</li>
</ul>
<pre><code class="ruby">nil || 99    # =&gt; 99
false || 99  # =&gt; 99
"cat" || 99  # =&gt; "cat"
b = (false or true)
b = false or true # Check b, Why??
</code></pre>
<p><small>
Es muy común utilizar la expresión: <code>||=</code> para setear un valor si no fue
seteado:
<br>
<code>var ||= "default value"</code>
</small></p>

</section>
<section>

<h2>Break, Redo y Next</h2>

<ul>
<li>Podemos alterar el flujo de ejecución de loops 

<ul>
<li>
<strong><code>break</code>:</strong> termina en forma inmediata al loop que se encuentra más próximo. El
control se devuelve a la sentencia siguiente al final del bloque</li>
<li>
<strong><code>redo</code>:</strong> repite la iteración actual sin evaluar la condición ni trayendo el
siguiente elemento si fuese un iterador</li>
<li>
<strong><code>next</code>:</strong> avanza hasta el final del bloque continuando con la siguiente
iteración</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo: Break</h2>
<pre><code class="ruby">a = 0
while a &lt; 20 do
  a +=1
  break if a == 10 
  p a 
end
</code></pre>
</section>
<section>

<h2>Ejemplo: Redo</h2>
<pre><code class="ruby">a = 0
while a &lt; 20 do
  a +=1
  redo if a == 10 
  p a 
end

# Y ahora?
a = 0
while a &lt; 20 do
  a +=1
  redo if a == 20 
  p a 
end
</code></pre>
</section>
<section>

<h2>Ejemplo: Next</h2>
<pre><code class="ruby">a = 0
while a &lt; 20 do
  a +=1
  next if a == 10 
  p a 
end

# Y ahora?
a = 0
while a &lt; 20 do
  a +=1
  next if a == 20 
  p a 
end
</code></pre>
</section>
</section>

<section>
<section>

<h1>Excepciones</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Las excepciones permiten empaquetar en un objeto información sobre un error </li>
<li>El objeto <code>Exception</code> se propagará hacia arriba en la pila de ejecución hasta
que el sistema detecte código que sepa manejar dicha excepción</li>
</ul>

</section>
<section>

<h2>La clase Exception</h2>

<ul>
<li>Ruby define una jerarquía de excepciones que son subclase de <code>Exception</code> </li>
<li>Esta jerarquía simplifica el manejo de excepciones

<ul>
<li>Al lanzar una excepción, es posible hacerlo con cualquiera de las subclases de
<code>Exception</code> o con una clase propia que sea subclase de <code>StandardError</code> o alguna
de sus hijas. </li>
</ul>
</li>
<li>Toda excepción tiene asociado un mensaje y una traza de ejecución

<ul>
<li>Si definimos excepciones propias, podemos agregar información específica</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Manejo de excepciones</h2>

<p>Analizamos el siguiente código</p>
<pre><code class="ruby">require 'open-uri'

web_page = open("http://pragprog.com/podcasts")
output = File.open("podcasts.html", "w")
while line = web_page.gets
  output.puts line
end
output.close
</code></pre>
<ul>
<li>¿Qué sucede si ocurre un error en la mitad de la transferencia?

<ul>
<li>No queremos guardar una página por la mitad en el archivo de salida</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Manejo de excepciones</h2>

<p>Agregamos el manejador de excepción</p>
<pre><code class="ruby">require 'open-uri'

page = "podcasts"
file_name = "#{page}.html"
web_page = open("http://pragprog.com/#{page}")
output = File.open(file_name, "w")
begin
  while line = web_page.gets
    output.puts line
  end
  output.close
rescue Exception
  STDERR.puts "Failed to download #{page}: #{$!}"
  output.close
  File.delete(file_name)
  raise
end
</code></pre>
</section>
<section>

<h2>Manejo de excepciones</h2>

<ul>
<li>Cuando sucede una excepción se ubica una referencia al objeto con la excepción
asociada en la variable global <code>$!</code>
</li>
<li>Luego de cerrar y eliminar el archivo, se invoca a <code>raise</code> sin parámetros, que
relanza la excepción en <code>$!</code>
</li>
</ul>

</section>
<section>

<h2>Jerarquía de Exception</h2>
<pre><code>  Exception
    StandardError
      ArgumentError
      FiberError (1.9)
      IndexError
        KeyError (1.9)
        StopIteration (1.9)
      IOError
        EOFError
      LocalJumpError
      NameError
        NoMethodError
      RangeError
        FloatDomainError
      RegexpError
      RuntimeError
      SystemCallError
        system-dependent exceptions (Errno::xxx)
      ThreadError
      TypeError
      ZeroDivisionError
    fatal
    NoMemoryError
    ScriptError
      LoadError
      NotImplementedError
      SyntaxError
    SecurityError 
    SignalException
      Interrupt
    SystemExit
    SystemStackError
</code></pre>
</section>
<section>

<h2>Múltiples rescue</h2>

<ul>
<li>Es posible utilizar varios <code>rescue</code> para un bloque <code>begin</code>
</li>
<li>Cada <code>rescue</code> puede incluso indicar varias excepciones a catchear</li>
<li>Al final de cada <code>rescue</code>, podemos indicar el nombre de la variable que
usaremos para mapear la exepción (en vez de usar <code>$!</code>)</li>
</ul>
<pre><code class="ruby">begin
  eval string
rescue SyntaxError, NameError =&gt; boom
  print "String doesn't compile: " + boom
rescue StandardError =&gt; bang
  print "Error running script: " + bang
end
</code></pre>
</section>
<section>

<h2>Cómo funciona rescue</h2>

<ul>
<li>La decisión de qué <code>rescue</code> utilizar, es similar al caso de un <code>case</code>
</li>
<li>Para cada <code>rescue</code> compara la excepción lanzada con cada uno de los parámetros
nombrados

<ul>
<li>La comparación es: <code>parámetro == $!</code>
</li>
<li>Esto significaría que si el tipo de la excepción lanzada coincide con el del
parámetro</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Cómo funciona rescue</h2>

<ul>
<li>Si se omiten parámetros, se compara con <code>StandardError</code>
</li>
<li>Si no machea con ningún parámetro, sale del bloque <code>begin/end</code> buscando en el
método que invocó un manejador para la misma, y así siguiendo hacia arriba en
la pila</li>
<li>Casi siempre usaremos nombre de clases como parámetros a <code>rescue</code>, pero
podemos usar expresiones que retornen una subclase de <code>Exception</code>
</li>
</ul>

</section>
<section>

<h2>Asegurando la ejecución</h2>

<ul>
<li>Varias veces necesitamos ejecutar determinado código al finalizar un método de
forma segura, es decir independientemente de si se produce un error en la
mitad

<ul>
<li>Por ejemplo, tenemos un archivo abierto, que necesitamos sea cerrado antes
de finalizar el bloque</li>
</ul>
</li>
<li>La cláusula <code>ensure</code> cumple esta función</li>
<li>El código bajo <code>ensure</code> se ejecutará siempre, haya sido una ejecución exitosa
o con algún problema</li>
</ul>

</section>
<section>

<h2>Un ejemplo ensure</h2>
<pre><code class="ruby">f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
ensure
  f.close
end
</code></pre>
</section>
<section>

<h2>El else de rescue</h2>

<ul>
<li>El <code>else</code> aplica cuando ninguno de los <code>rescue</code> manejan la excepción</li>
<li>Tener cuidado porque <code>ensure</code> ejecutará siempre, incluso cuando no se produce
un error</li>
</ul>
<pre><code class="ruby">f = File.open("testfile")
begin
  # .. process
rescue
  # .. handle error
else
  puts "Congratulations-- no errors!"
ensure
  f.close
end
</code></pre>
</section>
<section>

<h2>Volver a empezar...</h2>

<ul>
<li>A veces podemos corregir una causa de excepción</li>
<li>Para estos casos, podemos usar <code>retry</code> para volver a ejecutar el bloque
<code>begin/end</code>
</li>
<li>Es muy factible caer en loops infinitos </li>
</ul>

</section>
<section>

<h2>Ejemplo retry</h2>
<pre><code class="ruby">@esmtp = true
begin
# First try an extended login. If it fails 
# because the server doesn't support it, 
# fall back to a normal login
if @esmtp then
  @command.ehlo(helodom)
else
  @command.helo(helodom)
end
rescue ProtocolError
  if @esmtp then
    @esmtp = false
    retry
  else
    raise
  end
end
</code></pre>
</section>
<section>

<h2>Lanzando excepciones</h2>

<p>Podemos lanzar excepciones usando el método <code>Kernel.raise</code></p>
<pre><code class="ruby">raise
raise "bad mp3 encoding"
raise InterfaceException, "Keyboard failure", caller
</code></pre>
<ul>
<li>La primer forma relanza una excepción si la hubiere, o <code>RuntimeError</code> si no.
Usualemnte dentro de <code>rescue</code>
</li>
<li>El segundo ejemplo, lanza <code>RuntimeError</code> con el mensaje indicado</li>
<li>El tercer ejemplo, utiliza el primer parámetro para crear un excepción con el
segundo parámetro usado como mensaje y la pila de ejecución en el tercer
parámetro 

<ul>
<li>
<code>Kernel.caller</code> genera la traza de ejecución</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de raise</h2>
<pre><code class="ruby">raise
raise "Missing name" if name.nil?
if i &gt;= names.size
  raise IndexError, "#{i} &gt;= size (#{names.size})"
end
raise ArgumentError, "Name too big", caller
</code></pre>
<p><em>Generalmente no se incluye la traza en librerías</em></p>

</section>
<section>

<h2>catch y throw</h2>

<ul>
<li>Veremos un ejemplo que aclarará el concepto

<ul>
<li>El siguiente código leerá palabras que irá agregando en un arreglo que al
finalizar imprimirá en orden inverso. Sin embargo, si alguna línea es
incorrecta deberá salir sin hacer nada</li>
<li>El secreto es <code>throw(symbol, variable)</code>. <strong>En este ejemplo es importante que
el último puts retorna <code>nil</code></strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de catch y throw</h2>
<pre><code class="ruby">word_list = File.open("wordlist")
word_in_error = catch(:done) do
  result = []
  while line = word_list.gets
    word = line.chomp
    throw(:done, word) unless word =~ /^\w+$/
    result &lt;&lt; word
  end
  puts result.reverse
end
if word_in_error
  puts "Failed: '#{word_in_error}' found. Not a word"
end
</code></pre>
</section>
</section>

<section>
<section>

<h1>Unit Testing</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Unit testing es testing que se focaliza en pequeños bloques (o unidades)
de código

<ul>
<li>Típicamente se testean métodos individuales o líneas complejas de un método</li>
<li>Se contrasta con otras estrategias de testing que ven al sistema como un
todo</li>
</ul>
</li>
<li>Los sistemas de hoy día se desarrollan en capas donde cada una debería poder
confiar en que la capa de abstracción utilizada se desempeña correctamente, sin errores.

<ul>
<li>Un error en capas inferiores, causaría errores de propagación a capas
superiores</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Una situación</h2>

<p>Juan desarrolla una funcionalidad que tiene algún error no detectado. Unos dos
meses después, desarrollamos determinada funcionalidad que, indirectamente utiliza 
lo que Juan ha desarrollado. </p>

<p>Cuando nuestro código no devuelve los resultados
esperados, nos llevará un tiempo encontrar el problema dentro del código de 
Juan. Es entonces cuando consultamos con Juan: </p>

<p><strong><em>¿Por qué encaraste la solución así?</em></strong> </p>

<p>y la respuesta inmediata será: </p>

<p><strong>no recuerdo, fue hace varios meses</strong></p>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Si Juan hubira usado test de unidad para su código, dos cosas hubiesen sucedido: 

<ul>
<li>Juan podría haber encontrado el error cuando el código aún estaba <em>fresco en
su mente</em>
</li>
<li>Dado que el test de unidad sólo contempla las líneas que Juan escribió,
cuando ocurrió el problema, podría haber sido mucho más rápido analizar el
problema entorno al código problemático en vez de hacer arqueología en búsqueda
del problema en el resto del código</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Por qué conviene usar test de unidad?</h2>

<ul>
<li>Ayuda a los desarrolladores a escribir mejor código

<ul>
<li>Empezar escribiendo el test de unidad nos lleva a escribir código de mayor
calidad y diseños desacoplados</li>
<li>Es muy común que nos suceda que por no pensar los tests antes de escribir el
código, testear el código sea un tanto engorroso o difícil de probar por el
alto acoplamiento de entidades</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Por qué conviene usar test de unidad?</h2>

<ul>
<li>Ayuda mientras escribimos el código, porque nos va dando feedback del
comportamiento del código y ante nuevas dudas que van surgiendo sobre posibles
casos extraños, nos permite escribir nuevos tests para agregar a nuestra suite
y así quedarnos tranquilos que los casos contemplados en el código son testeados</li>
<li>Ayuda luego de haber escrito el código por dos razones:

<ul>
<li>Chequeando que el código sigue funcionando a medida que el desarrollo crece</li>
<li>Permite a otros desarrolladores entender mejor cómo utilizar nuestro código</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>La trivialidad</h2>

<p>Los tests de unidad son simples:</p>

<p><em>consiste en correr un programa que invocan una parte del código de nuestra
aplicación, obtiene algunos resultados y verifica que  dichos resultados
sean los esperados</em></p>

</section>
<section>

<h2>Un ejemplo</h2>

<p>Escribir una clase llamada <code>Roman</code> que permita crear objetos con un valor
numérico y que imprima el valor como un número romano</p>

</section>
<section>

<h2>El programa</h2>
<pre><code class="ruby">class Roman
  MAX_ROMAN = 4999

  def initialize(value)
    if value &lt;= 0 || value &gt; MAX_ROMAN
      fail "Roman values must be &gt; 0 and &lt;= #{MAX_ROMAN}"
    end
    @value = value
  end

  FACTORS = [["m",1000], ["cm",900], ["d",500], ["cd",400],
             ["c",100], ["xc",90], ["l",50], ["xl",40],
             ["x",10], ["ix",9], ["v",5], ["iv",4], ["i",1]]

  def to_s
    value = @value
    roman = ""
    for code, factor in FACTORS
      count, value = value.divmod(factor)
      roman &lt;&lt; code unless count.zero?
    end
    roman
  end
end
</code></pre>
</section>
<section>

<h2>¡Lo probamos con los dientes!</h2>

<ul>
<li>Usando  <code>irb</code>
</li>
<li>Escribiendo un programa de test</li>
</ul>
<pre><code class="ruby">require 'roman'
r = Roman.new(1)
fail "'i' expected" unless r.to_s == "i"
r = Roman.new(9)
fail "'ix' expected" unless r.to_s == "ix"
</code></pre>
<p>Pero Ruby ya incorpora un framework de tests de unidad:</p>

<ul>
<li>Hasta 1.8 era Test::Unit</li>
<li>A partir de 1.9 es MiniTest</li>
</ul>

</section>
<section>

<h2>Test::Unit vs MiniTest::Unit</h2>

<ul>
<li>Durante muchos años <code>Test::Unit</code> era la opción de la mayor parte de los
desarrolladores</li>
<li>Sin embargo, el core team de ruby decidió optar por Minitest::Unit por ser
mucho más liviano</li>
<li>La mayor parte de las <code>assertions</code> de <code>MiniTest</code> se espejan con las
definidas en <code>Test::Unit::TesCase</code>
</li>
</ul>

</section>
<section>

<h2>MiniTest</h2>

<p>Aparecen dos opciones de uso:</p>

<ul>
<li>
<code>require 'minitest/unit'</code> similar a Test::Unit</li>
<li>
<code>require 'minitest/spec'</code> utiliza el formato de <em>specs</em> introducido por
<strong><a href="http://rspec.info/">rspec</a></strong>
</li>
</ul>

</section>
<section>

<h2>El framework de testing</h2>

<ul>
<li>El framework de testing provisto por Ruby provee básicamente tres
funcionalidades en un mismo paquete:

<ul>
<li>Provee una forma de expresar tests individuales</li>
<li>Provee un framework para la estructuración de los tests</li>
<li>Ofrece diversas formas flexibles de invocar los tests</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Assertions</h2>

<ul>
<li>En vez de escribir un montón de <code>if/unless</code> se utilizan <strong>assertions</strong> que
provee el framework de test</li>
<li>Existen muchos tipos de assertions, pero básicamente todos siguen el mismo
patrón: 

<ul>
<li>Cada assertion provee una forma de especificar un <em>resultado esperado</em> y la
forma de pasar el valor actual </li>
<li>Si el valor actual no es el <em>resultado esperado</em>, la assertion imprimirá un
mensaje y contabilizará el fallo</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>El ejemplo de Roman</h2>

<p>Reescribimos los tests que hicimos con los dientes</p>
<pre><code class="ruby">require_relative 'roman'
require 'minitest/autorun'
require 'minitest/unit'
class TestRoman &lt; MiniTest::Test
  def test_simple
    assert_equal("i", Roman.new(1).to_s)
    assert_equal("ix", Roman.new(9).to_s)
  end
end
</code></pre>
<p><em>Lo probamos</em></p>

<p><small class="fragment">
<a href="images/samples/11/romans/version-1/test.rb">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Agregamos más assertions</h2>
<pre><code class="ruby">require_relative 'roman'
require 'minitest/autorun'
require 'minitest/unit'
class TestRoman &lt; MiniTest::Test
  def test_simple
    assert_equal("i",  Roman.new(1).to_s)
    assert_equal("ii", Roman.new(2).to_s)
    assert_equal("iii",Roman.new(3).to_s)
    assert_equal("iv", Roman.new(4).to_s)
    assert_equal("ix", Roman.new(9).to_s)
  end
end
</code></pre>
<p><em>Lo probamos</em></p>

<p><small class="fragment">
<a href="images/samples/11/romans/version-2/test.rb">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h1>Encontramos un ERROR</h1>

</section>
<section>

<h2>Analizamos el problema</h2>

<p>Miramos el <code>to_s</code></p>
<pre><code class="ruby">def to_s
  value = @value
  roman = ""
  for code, factor in FACTORS
    count, value = value.divmod(factor)
    roman &lt;&lt; (code * count)
    # cambiamos: unless count.zero?
  end
  roman
end
</code></pre>
<p><em>Lo probamos</em></p>

</section>
<section>

<h2>Refactorizando el test</h2>

<p>Para no repetir los asserts, podemos:</p>
<pre><code class="ruby">require_relative 'roman'
require 'minitest/autorun'
require 'minitest/unit'
class TestRoman &lt; MiniTest::Test
  NUMBERS = [
             [ 1, "i" ], [ 2, "ii" ], [ 3, "iii" ],
             [ 4, "iv"], [ 5, "v" ], [ 9, "ix" ]
            ]
  def test_simple
    NUMBERS.each do |arabic, roman|
      r = Roman.new(arabic)
      assert_equal(roman, r.to_s)
    end
  end
end
</code></pre>
<p><em>Podemos testear muchas cosas, por ejemplo el constructor de la clase <code>Roman</code></em></p>

</section>
<section>

<h2>Verificamos si se lanzan las excepciones</h2>
<pre><code class="ruby">require_relative 'roman'
require 'minitest/autorun'
require 'minitest/unit'
class TestRoman &lt; MiniTest::Test
  def test_range
    # no exception for these two...
    Roman.new(1)
    Roman.new(4999)
    # but an exception for these
    assert_raises(RuntimeError) { Roman.new(0) }
    assert_raises(RuntimeError) { Roman.new(5000) }
  end
end
</code></pre>
<p><em>Analicemos qué más testear en la clase <code>Roman</code> que genera números hasta 4999</em></p>

<p><small class="fragment">
<a href="images/samples/11/romans/version-3/test.rb">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Listado de assertions</h2>
<pre><code class="ruby">assert | refute(boolean, [ message ] )
# Fails if boolean is (is not) false or nil.

assert_block { block }
# Expects the block to return true.

assert_ | refute_empty(collection, [ message ] )
# Expects empty? on collection to return true (false).

assert_ | refute_equal(expected, actual, [ message ] )
# Expects actual to equal/not equal expected, using ==.

assert_ | refute_in_delta(expected_float, actual_float, 
                          delta, [ message ] )
# Expects that the actual floating-point value is (is not) 
# within delta of the expected value.

assert_ | refute_in_epsilon(expected_float, actual_float, 
                            epsilon=0.001, [ message ] )
# Calculates a delta value as epsilon * min(expected, actual),
# then calls the _in_delta test.

assert_ | refute_includes(collection, obj, [ message ] )
# Expects include?(obj) on collection to return true (false).

assert_ | refute_instance_of(klass, obj, [ message ] )
# Expects obj to be (not to be) a instance of klass.

assert_ | refute_kind_of(klass, obj, [ message ] )
# Expects obj to be (not to be) a kind of klass.

assert_ | refute_match(regexp, string, [ message ] )
# Expects string to (not) match regexp.

assert_ | refute_nil(obj, [ message ] )
# Expects obj to be (not) nil.

assert_ | refute_operator(obj1, operator, obj2, [ message ] )
# Expects the result of sending the message operator to obj1 
# with parameter obj2 to be (not to be) true.

assert_raises(Exception, . . . ) { block }
# Expects the block to raise one of the listed exceptions.

assert_ | refute_respond_to(obj, message, [ message] )
# Expects obj to respond to (not respond to) message (a symbol).

assert_ | refute_same(expected, actual, [ message ] )
# Expects expected.equal?(actual).

assert_send(send_array, [ message ] )
# Sends the message in send_array[1] to the receiver in 
# send_array[0], passing the rest of send_array as arguments. 
# Expects the return value to be true.

assert_throws(expected_symbol, [ message ] ) { block }
# Expects the block to throw the given symbol.

flunk(message="Epic Fail!")
# Always fails.

skip(message)
# Indicates that a test is deliberately not run.

pass
# Always passes.
</code></pre>
<p><small>
<em>Notar que el último parámetro es un mensaje que será usado en la salida ante un error.
Generalmente no es necesario usarlo porque el error es bastante claro, salvo <code>refute_nil</code> 
que devolvería <strong>Expected nil to not be nil</strong></em>
</small></p>

</section>
<section>

<h2>Minitest Spec</h2>

<p>Veamos ahora como sería el mismo último test escrito en este nuevo formato</p>
<pre><code class="ruby">require_relative 'roman'
require 'minitest/autorun'
require 'minitest/spec'
describe Roman do
  NUMBERS = [ [ 1, "i" ], [ 2, "ii" ], [ 3, "iii" ],
    [ 4, "iv"], [ 5, "v" ], [ 9, "ix" ] ]
  describe 'when arbitrary numbers are converted' do
    it 'must return expected value' do
      NUMBERS.each do |arabic, roman|
        r = Roman.new(arabic)
        assert_equal(roman, r.to_s)
      end
    end
  end

  describe 'limits' do 
    it 'should not raise exceptions for these two' do
      Roman.new(1)
      Roman.new(4999)
    end
    it 'should raise an exception for limits' do
      assert_raises(RuntimeError) { Roman.new(0) }
      assert_raises(RuntimeError) { Roman.new(5000) }
    end
  end
end
</code></pre>
</section>
<section>

<h2>Estructurando los tests</h2>

<ul>
<li>Los tests de unidad nos llevan a dos agrupamientos:

<ul>
<li>
<strong>De alto nivel</strong>: llamados <em>test cases</em>. Contienen todos los tests para una
característica determinada. En el ejemplo de <code>Roman</code> alcanza con un único
test case. Las clases que representan test cases, deben ser subclase de:
<code>Minitest::Test</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Estructurando los tests</h2>

<ul>
<li>
<strong>De bajo nivel</strong>: que serían los métodos de test en sí. Los assertions
podríamos escribirlos todos mezclados, pero en su lugar los agrupamos en
métodos dentro del test case de forma de que los assertions en un método se
corresponden con un tipo de test: <em>uno testearía manejo de errores, otro
métodos de inicialización, límites, etc</em>. Los métodos de test, deben
comenzar con el prefijo <strong>test</strong> para que sean seleccionados como tales</li>
</ul>

</section>
<section>

<h2>Antes y despues...</h2>

<p>Generalmente queremos ejecutar determinado código antes y luego de cada test.
Disponemos entonces de:</p>

<ul>
<li>
<code>setup</code> en Unit o <code>before</code> en Spec</li>
<li>
<code>teardown</code> en Unit o <code>after</code> en Spec</li>
</ul>

<p><small>
Ver ejemplo <a href="images/samples/11/setup-teardown/test_spec.rb">minitest-spec</a> y
<a href="images/samples/11/setup-teardown/test_unit.rb">minitest-unit</a>
</small></p>

</section>
<section>

<h2>Otros agregados</h2>

<ul>
<li>
<p>Mocks</p>

<ul>
<li>minitest/mock</li>
<li>Mocha: <a href="https://github.com/freerange/mocha">https://github.com/freerange/mocha</a></li>
</ul>
</li>
<li>
<p>Coverage con <a href="https://github.com/colszowka/simplecov">simplecov</a></p>

<ul>
<li><a href="images/samples/11/coverage/index.html">Ejemplo de salida simplecov</a></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Más sobre testing</h2>

<p>Es interesante seguir investigando sobre:</p>

<ul>
<li>
<a href="https://github.com/brynary/rack-test">Rack Test</a> (lo veremos más adelante)</li>
<li><a href="https://cucumber.io/">Cucumber</a></li>
<li><a href="https://github.com/jnicklas/capybara">Capybara</a></li>
<li><a href="http://jmeter.apache.org/">JMeter</a></li>
<li><a href="https://github.com/tsenart/vegeta">Vegeta</a></li>
</ul>

</section>
</section>

<section>
<section>

<h1>Gemas</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Una gema es un formato simple para publicar y compartir código Ruby.</li>
<li>Cada gema tiene un nombre, versión y plataforma.</li>
</ul>

</section>
<section>

<h2>Comandos básicos</h2>

<ul>
<li>Instalar una gema: <code>gem install rake</code>
</li>
<li>Buscar una gema: <code>gem search sinatra</code>
</li>
<li>Listar gemas instaladas: <code>gem list</code>
</li>
</ul>

</section>
<section>

<h1>Bundler</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Mantiene un entorno consistente para las aplicaciones ruby</li>
<li>Asegura que la aplicación que lo use tenga las dependencias necesarias
para que se ejecute sin errores.</li>
<li>Bundler es una gema: <code>gem install bundler</code>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<p>Definimos las dependencias en el archivo <code>Gemfile</code></p>
<pre><code class="ruby">source 'https://rubygems.org'

gem 'sinatra'
</code></pre>
<p><small>
Luego instalamos las dependencias con <code>bundle install</code> o simplemente <code>bundle</code>
</small></p>

</section>
<section>

<h2>Comandos</h2>
<pre><code class="bash"># Instalar dependencias:
bundle install

# Actualizar dependencias a sus últimas versiones:
bundle update

# Ejecutar un script en el contexto del bundle actual:
bundle exec

# Ver las gemas instaladas en el bundle actual:
bundle list

# Ver donde está ubicada una gema:
bundle show NOMBRE_GEMA
</code></pre>
</section>
<section>

<h2>Gemfile</h2>

<ul>
<li>Se escribe con una DSL propia de bundler (extraida de Rubygems)</li>
<li>Puede incluir cualquier código ruby!</li>
<li>La sentencia <code>gem</code> indica una dependencia y acepta los siguientes
parámetros:

<ul>
<li>versión, por ejemplo: <code>'&gt;= 1.1.0'</code>, <code>'~&gt; 3.1.2'</code>
</li>
<li>github (construir la gema a partir de un repositorio en github): <code>github: 'sinatra/sinatra'</code>
</li>
<li>path: para una gema local</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="ruby">source 'https://rubygems.org'
gem 'sinatra', github: 'sinatra/sinatra'
gem 'activerecord', '~&gt; 3.1.0'
</code></pre>
</section>
<section>

<h2>Usando bundler</h2>

<ul>
<li>Con declarar las dependencias en el <code>Gemfile</code> no basta, hay que invocar a bundler.</li>
<li>Hay dos formas:</li>
</ul>

<p>Bundler requiere los archivos</p>
<pre><code class="ruby">require 'bundler'
Bundler.require
</code></pre>
<p>Bundler configura, pero los require son explícitos</p>
<pre><code class="ruby">require 'bundler'
Bundler.setup
require 'sinatra'
</code></pre>
</section>
<section>

<h2>Con el Gemfile podremos establecer</h2>

<ul>
<li>
<p>La fuente de donde obtener las gemas: <code>source 'https://rubygems.org'</code></p>

<ul>
<li>Especificarlo para una gema en particular o agrupar gemas por sources</li>
</ul>
</li>
<li><p>Cómo se require la gema: usando <code>require: 'string'</code> o
<code>require: false</code></p></li>
<li><p>Versión de una gema: <code>&gt;= x.y</code> o <code>~&gt; x.y.z</code></p></li>
</ul>

</section>
<section>

<h2>Con el Gemfile podremos establecer</h2>

<ul>
<li><p>Tag, branch o ref de un repo git</p></li>
<li>
<p>Grupos de gemas con el fin de poder requerir o instalarlas en forma modular:
<code>group: :development</code></p>

<ul>
<li>Relacionado con <code>Bundler.setup</code> y <code>Bundler.require</code>
</li>
</ul>
</li>
<li><p>Plataforma para la cual aplican determinadas gemas: <code>patforms:
[:jruby, :ruby]</code></p></li>
</ul>

</section>
<section>

<h2>Ejemplo de Gemfile</h2>
<pre><code class="ruby">source 'https://rubygems.org'

gem 'thin',  '~&gt;1.1'

gem 'rspec', :require =&gt; 'spec'

gem 'my_gem', '1.0', :source =&gt; 'https://gems.example.com'

gem 'mysql2', platform: :ruby
gem 'jdbc-mysql', platform: :jruby
gem 'activerecord-jdbc-adapter', platform: :jruby

source 'https://gems.example.com' do
  gem 'another_gem', '1.2.1'
end

gem 'nokogiri', 
  :git =&gt; 'https://github.com/tenderlove/nokogiri.git', 
  :branch =&gt; '1.4'

gem 'extracted_library', :path =&gt; './vendor/extracted_library'

gem 'wirble', :group =&gt; :development
gem 'debugger', :group =&gt; [:development, :test]
group :test do
  gem 'rspec'
end
</code></pre>
<p><small>
<a href="https://github.com/redmine/redmine/blob/master/Gemfile">Ver ejemplo de Redmine</a>
</small></p>

</section>
</section>

<section>
<section>

<h1>HTTP</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Es un protocolo de red de la capa de aplicación</li>
<li>Se ha convertido en el principal protocolo de comunicación entre clientes y servidores</li>
<li>Cuando un cliente (un browser, una aplicación web, un servicio) quiere
interactuar con un servidor sobre HTTP le envía un mensaje (<strong>Request</strong>)</li>
<li>Luego, cuando el servidor termina de procesar el Request puede comunicar
información al cliente creando un mensaje HTTP propio (<strong>Response</strong>).</li>
</ul>

</section>
<section>

<h2>Requerimiento HTTP</h2>

<ul>
<li>
<strong>Start line</strong>: Es la primera línea del Request. Identifica el
<strong>Verbo HTTP</strong>, a que recurso acceder y denota la versión de HTTP a usar.</li>
<li>
<strong>Headers</strong>: Proveen información adicional acerca del Request. Ejemplos de
headers son: los valores de las cookies para el dominio, el tipo de contenido
a aceptar, etc.</li>
<li>
<strong>Message Body</strong>: Puede contener datos binarios o de texto. Por ejemplo,
cuando se sube una imagen a facebook, los datos binarios de la foto son
enviados en este campo. Este campo no es obligatorio.</li>
</ul>

</section>
<section>

<h2>Ejemplo de requerimiento HTTP</h2>
<pre><code class="http">GET /capacitacion-ruby-ttps/ HTTP/1.1
Host: ttps-ruby.github.io
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Accept: text/html,application/xhtml+xml, application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.104 Safari/537.36
Accept-Encoding: gzip,deflate,sdch
Accept-Language: es-ES,es;q=0.8
</code></pre>
</section>
<section>

<h2>Respuesta HTTP</h2>

<ul>
<li>El <strong>Response</strong> usualmente contiene la siguiente información:

<ul>
<li>
<strong>status</strong>: si el <strong>Request</strong> del cliente fue exitoso, si ocurrió un
error, etc.</li>
<li>
<strong>headers</strong>: por ejemplo que tipo de contenido se envía al cliente, etc.</li>
<li>
<strong>body</strong>: por ejemplo, un documento HTML</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de respuesta HTTP</h2>
<pre><code>HTTP/1.1 200 OK
Server: GitHub.com
Content-Type: text/html; charset=utf-8
Last-Modified: Tue, 21 Oct 2014 02:06:17 GMT
Expires: Sun, 26 Oct 2014 23:05:15 GMT
Cache-Control: max-age=600
Content-Encoding: gzip
Content-Length: 78296
Accept-Ranges: bytes
Date: Sun, 26 Oct 2014 22:55:48 GMT

...........{..W.....UT.&gt;.....$`...C.r ....L&amp;.?.T.
...gN...k_......=.{../.g'..~.../.&gt;..V......[_...Q
</code></pre>
</section>
<section>

<h2>Un poco de historia de HTTP</h2>

<ul>
<li>Protocolo usado para la WWW.</li>
<li>RFC 2616: <a href="http://www.ietf.org/rfc/rfc2616.txt">http://www.ietf.org/rfc/rfc2616.txt</a></li>
<li>Lanzado en el año 1999</li>
<li>Protocolo sin estado (Stateless)</li>
<li>El acceso a los recursos se hace por medio
de métodos:

<ul>
<li>HTTP 1.0: GET, HEAD, POST</li>
<li>HTTP 1.1: agrega PUT, DELETE, OPTIONS, TRACE, CONNECT</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Algunos detalles del protocolo</h2>

<ul>
<li>Los métodos GET, HEAD, PUT, DELETE son considerados idempotentes: 

<ul>
<li>El resultado de invocar el método es el mismo que hacerlo N
veces (N &gt; 1)</li>
</ul>
</li>
<li>Lo mismo aplica para OPTIONS y TRACE dado que no deberían tener efectos
secundarios, y por ende heredan la propiedad</li>
</ul>

</section>
<section>

<h2>Verbos HTTP</h2>

<ul>
<li>
<strong>GET</strong>: se usa para pedirle al servidor web la representación de un
recurso.</li>
<li>
<strong>POST</strong>: se usa para enviar datos a un servidor web.</li>
<li>
<strong>PUT</strong>: se usa para crear o actualizar la representación de un recurso en
un servidor web.</li>
<li>
<strong>DELETE</strong>: se usa para destruir un recurso en un servidor web.</li>
<li>
<strong>PATCH</strong>: se usa para actualizar una parte de un recurso.</li>
<li>La especificación de HTTP también define <strong>OPTIONS</strong>, <strong>HEAD</strong>, <strong>TRACE</strong> y
<strong>CONNECT</strong>, los cuales dejaremos de lado.</li>
</ul>

</section>
<section>

<h2>El mejor amigo de HTTP: curl</h2>

<p>Curl es una librería empleada para interactuar con varios protocolos,
especialmente HTTP</p>
<pre><code class="bash">$ curl -X GET \
  http://ttps-ruby.github.io/capacitacion-ruby-ttps/ -i
HTTP/1.1 200 OK
Server: GitHub.com
Content-Type: text/html; charset=utf-8
Last-Modified: Tue, 21 Oct 2014 02:06:17 GMT
Expires: Sun, 26 Oct 2014 23:36:24 GMT
Cache-Control: max-age=600
Content-Length: 281844
Accept-Ranges: bytes
Date: Sun, 26 Oct 2014 23:26:24 GMT
Via: 1.1 varnish
Age: 0
Connection: keep-alive
X-Served-By: cache-iad2134-IAD
X-Cache: MISS
X-Cache-Hits: 0
X-Timer: S1414365984.304589,VS0,VE7
Vary: Accept-Encoding

...
</code></pre>
</section>
</section>

<section>
<section>

<h1>SINATRA</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Es una DSL para desarrollar aplicaciones y web services en Ruby basado en
<strong>Rack</strong> (Recordar este término, lo nombraremos mucho de aquí en adelante)</li>
<li>Hace énfasis en el desarrollo minimalista, ofreciendo sólo lo que es
esencial para manejar Requests HTTP y entregar Responses a los clientes.</li>
<li>Tiene una sintaxis simple</li>
<li>No es un framework:

<ul>
<li>No tiene un ORM</li>
<li>No tiene archivos de configuración</li>
<li>No hay estructura de archivos</li>
</ul>
</li>
<li>No fuerza a implementar MVC ni ningún otro patrón</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<p>Creamos un directorio e inicializamos con <code>bundle init</code></p>

<h3>El Gemfile</h3>
<pre><code class="ruby">source 'https://rubygems.org'
gem 'sinatra'
</code></pre>
<h3>El server</h3>
<pre><code class="ruby">require 'bundler'
Bundler.require

get '/' do
  'hello world'
end
</code></pre>
</section>
<section>

<h2>Probamos el server</h2>

<p>Asumiendo el server se guarda en el archivo <code>server.rb</code>,
ejecutamos: <code>ruby server.rb</code></p>
<pre><code class="bash">$ curl -v http://localhost:4567/
&gt; GET / HTTP/1.1
&gt; User-Agent: curl/7.35.0
&gt; Host: localhost:4567
&gt; Accept: */*
&gt; 
&lt; HTTP/1.1 200 OK 
HTTP/1.1 200 OK 
&lt; Content-Type: text/html;charset=utf-8
Content-Type: text/html;charset=utf-8
&lt; Content-Length: 11
Content-Length: 11
&lt; X-Xss-Protection: 1; mode=block
X-Xss-Protection: 1; mode=block
&lt; X-Content-Type-Options: nosniff
X-Content-Type-Options: nosniff
&lt; X-Frame-Options: SAMEORIGIN
X-Frame-Options: SAMEORIGIN
* Server WEBrick/1.3.1 (Ruby/2.1.2/2014-05-08) is not blacklisted
&lt; Server: WEBrick/1.3.1 (Ruby/2.1.2/2014-05-08)
Server: WEBrick/1.3.1 (Ruby/2.1.2/2014-05-08)
&lt; Date: Sun, 26 Oct 2014 23:35:04 GMT
</code></pre>
</section>
<section>

<h2>¿Y cómo lo testeamos?</h2>

<ul>
<li>Para testear aplicaciones sinatra usaremos una gema llamada <code>rack-test</code>
</li>
<li>Para testear el ejemplo, haremos un request <code>GET /</code> y esperaremos que nos
devuelva un código de estado <code>200</code> (OK) y que el body sea <code>'hello world'</code>
</li>
</ul>

</section>
<section>

<h2>Testeando</h2>

<p>Como usamos bundler, editamos el <code>Gemfile</code></p>
<pre><code class="ruby">source 'https://rubygems.org'
gem 'sinatra'
gem "minitest"
gem "rack-test" 
</code></pre>
</section>
<section>

<h2>¿Cómo lo testeamos?</h2>
<pre><code class="ruby">require_relative 'server'
require 'minitest/autorun'

class HelloWorldTest &lt; MiniTest::Test
  include Rack::Test::Methods

  def app
    Sinatra::Application
  end

  def test_get_root
    get '/'
    assert_equal 200, last_response.status
    assert last_response.ok?
    assert_equal 'hello world', last_response.body
  end
end
</code></pre>
<p><small>
<a href="images/samples/14/sinatra-test.zip">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Y si queremos usar mintest/spec</h2>
<pre><code class="ruby">require_relative 'server'
require 'minitest/autorun'
require 'minitest/spec'

include Rack::Test::Methods

def app
  Sinatra::Application
end

describe 'my example server' do
  it 'should succeed' do
    get '/'
    last_response.status.must_equal 200
    last_response.must_be :ok?
    last_response.body.must_include 'hello world'
  end
end
</code></pre>
</section>
<section>

<h2>Rutas en Sinatra</h2>

<ul>
<li>En sinatra una ruta es la dupla de un método HTTP, con un patrón de URL</li>
<li>A cada ruta se le asocia un bloque</li>
<li>Las rutas se machean en el orden en que fueron definidas</li>
<li>Los patrones de rutas podrán:

<ul>
<li>Incluir parámetros nombrados: accesibles usando el hash <code>params</code> o como un
parámetro del bloque</li>
<li>Utilizar argumentos <strong>splat</strong>: accesibles mediante <code>params[:splat]</code> o
parámtros del bloque</li>
<li>Expresiones regulares</li>
<li>Incluir parámetros de consulta: <code>?some_param=value&amp;other=other_value</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Rutas: verbos</h2>
<pre><code class="ruby">require 'bundler'
Bundler.require

get '/' do
  'This is GET'
end

post '/' do
  'This is POST'
end

put '/' do
  'This is PUT'
end

patch '/' do
  'This is PATCH'
end

delete '/' do
  'This is DELETE'
end
</code></pre>
</section>
<section>

<h2>Lo probamos</h2>
<pre><code class="bash">$ curl -X GET http://localhost:4567/
This is GET
$curl -d '' -X PUT http://localhost:4567/ 
This is PUT
$ curl -d '' -X POST http://localhost:4567/ 
This is POST
$ curl -d '' -X DELETE http://localhost:4567/ 
This is DELETE
$ curl -d '' -X PATCH http://localhost:4567/ 
This is PATCH
</code></pre>
</section>
<section>

<h2>Ejemplos de rutas: patrones con parámetros</h2>
<pre><code class="ruby">get '/hello/:name' do
  # matches "GET /hello/foo" and "GET /hello/bar"
  # params[:name] is 'foo' or 'bar'
  "Hello #{params[:name]}!"
end

# O usando variables de bloque
get '/hello/:name' do |n|
  # matches "GET /hello/foo" and "GET /hello/bar"
  # params[:name] is 'foo' or 'bar'
  # n stores params[:name]
  "Hello #{n}!"
end
</code></pre>
</section>
<section>

<h2>Rutas: patrones con splats</h2>
<pre><code class="ruby">get '/say/*/to/*' do
  # matches /say/hello/to/world
  params[:splat] # =&gt; ["hello", "world"]
end

get '/download/*.*' do
  # matches /download/path/to/file.xml
  params[:splat] # =&gt; ["path/to/file", "xml"]
end

# O usando variales de bloque
get '/download/*.*' do |path, ext|
  [path, ext] # =&gt; ["path/to/file", "xml"]
end
</code></pre>
</section>
<section>

<h2>Rutas: patrones basados en regexp</h2>
<pre><code class="ruby">get %r{/hello/([\w]+)} do
  "Hello, #{params[:captures].first}!"
end

# O usando variables de bloque
get %r{/hello/([\w]+)} do |c|
  "Hello, #{c}!"
end
</code></pre>
</section>
<section>

<h2>Rutas: con parámetros de consulta</h2>
<pre><code class="ruby">get '/posts' do
  # matches "GET /posts?title=foo&amp;author=bar"
  title = params[:title]
  author = params[:author]
end
</code></pre>
</section>
<section>

<h2>Sinatra: Condiciones</h2>

<ul>
<li>Las rutas de sinatra pueden incluir condiciones de match como por ejemplo:

<ul>
<li>
<code>agent</code>: condiciones sobre el UA</li>
<li>
<code>provides</code>: condiciones sobre el content type</li>
<li>
<code>host_name</code>: condiciones sobre el server name</li>
<li>definidas por el usuario</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de Condiciones</h2>
<pre><code class="ruby">get '/foo', :agent =&gt; /Songbird (\d\.\d)[\d\/]*?/ do
  "You're using Songbird version #{params[:agent][0]}"
end

get '/foo' do
  # Matches non-songbird browsers
end
</code></pre>
<p>¿Cómo probar?</p>
<pre><code class="bash">curl http://localhost:4567/foo -A 'Songbird 1.1'
</code></pre>
</section>
<section>

<h2>Ejemplo de condiciones con host_name y provides</h2>
<pre><code class="ruby">get '/', :host_name =&gt; /^admin\./ do
  "Admin Area, Access denied!"
end

get '/', :provides =&gt; 'html' do
  'HTML'
end

get '/', :provides =&gt; ['rss', 'atom', 'xml'] do
  'XML'
end
</code></pre>
<p>¿Cómo probar?</p>
<pre><code class="bash">curl http://localhost:4567 -H "Accept: application/xml"
</code></pre>
</section>
<section>

<h2>Ejemplo de condiciones propias</h2>
<pre><code class="ruby">set(:probability) do |value| 
  condition { rand &lt;= value }
end

get '/win_a_car', :probability =&gt; 0.1 do
  "You won!"
end

get '/win_a_car' do
  "Sorry, you lost."
end
</code></pre>
</section>
<section>

<h2>Ejemplo de condiciones propias</h2>
<pre><code class="ruby">set(:auth) do |*roles|   # &lt;- notice the splat here
  condition do
    unless logged_in? &amp;&amp; 
      roles.any? {|role| current_user.in_role? role }
        redirect "/login/", 303
    end
  end
end

get "/my/account/", :auth =&gt; [:user, :admin] do
  "Your Account Details"
end

get "/only/admin/", :auth =&gt; :admin do
  "Only admins are allowed here!"
end
</code></pre>
</section>
<section>

<h2>Sinatra: valor de retorno</h2>

<ul>
<li>El valor de retorno de un bloque de ruta determina al menos el cuerpo de la
respuesta que se le pasa al cliente HTTP o al siguiente middleware en la pila
de Rack.</li>
<li>Lo más común es que sea un string, como en los ejemplos anteriores.</li>
</ul>

</section>
<section>

<h2>Sinatra: características</h2>

<ul>
<li>
<strong>Archivos estáticos</strong>: Son servidos desde el directorio <code>public</code>.

<ul>
<li>Podemos modificar esta opción con <code>set :public_folder, File.dirname(__FILE__) + '/static'</code>
</li>
</ul>
</li>
<li>
<strong>Vistas/Plantillas</strong>: Sinatra soporta numerosos template engines, y para
renderizar vistas de cada template engine se expone un método con su mismo
nombre. A estos métodos debe pasársele un símbolo con el nombre de la vista
a utilizar, que debe ser guardado en el directorio <code>views</code>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="ruby">get '/' do
  @name = 'Frank Sinatra'
  erb :index
end
</code></pre>
<p>El archivo <code>views/index.erb</code></p>
<pre><code class="html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Welcome&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    Hello, &lt;%= @name %&gt;!
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
</section>
<section>

<h2>Templates</h2>

<ul>
<li>Los templates aceptan las siguientes opciones:

<ul>
<li>
<strong>locals</strong>: lista de variables pasadas al template</li>
<li>
<strong>default_encoding</strong>: codificación de caracteres. Por defecto se usa 
<code>settings.default_encoding</code>
</li>
<li>
<strong>views</strong>: directorio de donde cargar los templates. Por defecto <code>settings.views</code>
</li>
</ul>
</li>
</ul>

<p><small>
Continúa
</small></p>

</section>
<section>

<h2>Templates</h2>

<ul>
<li>
<strong>layout</strong>: utilizar o no layout (true/false). Si es un símbolo, especifica
que templeta usar</li>
<li>
<strong>Content-Type</strong>: tipo de contenido producido por el template. </li>
<li>
<strong>scope</strong>: alcance en el cual renderiza el template. Por defecto es la
aplicación. Si se cambia, las variables de instancia y helpers no estarán
disponibles.</li>
</ul>

<p><small>
<a href="images/samples/14/sinatra-template.zip">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Templates: directorio de las vistas</h2>
<pre><code class="ruby">set :views, settings.root + '/templates'
</code></pre>
<p><small>
Es importante recordar que los templates deben referenciarse siempre con
símbolos, aun si se encuentran en un subdirectorio (en este caso usar:
<code>:subdir/template</code> o <code>'subdir/template'.to_sym</code>). <em><strong>Debe siempre usarse un símbolo
sino se toma el string y renderiza directamente.</strong></em>
</small></p>

</section>
<section>

<h2>Layout</h2>

<ul>
<li>El layout es un template contenedor que enmarca lo que cada acción renderiza.</li>
<li>Para embeber utilizaremos <code>yield</code>
</li>
</ul>
<pre><code class="ruby">get '/template' do
  @name='Some name'
  erb :sample
end
</code></pre>
<p><small>
El código anterior, buscará el layout <code>views/layout.erb</code> y el template <code>views/sample.erb</code>
</small></p>

</section>
<section>

<h2>Filtros: before y after</h2>

<p>Los filtros <code>before</code> son evaluados antes de cada petición
dentro del mismo contexto que las rutas. Pueden modificar la petición y la
respuesta. Las variables de instancia asignadas en los filtros son accesibles
por las rutas y las plantillas (idem con <code>after</code>):</p>
<pre><code class="ruby">    before do
      @nota = 'Hey!'
    end

    get '/' do
      @nota #=&gt; 'Hey!'
    end
</code></pre>
</section>
<section>

<h2>Filtros: before y after</h2>

<ul>
<li>El filtro <code>after</code> ejecuta luego de atender la petición</li>
<li>Los filtros pueden contener una ruta para machear cuándo aplican

<ul>
<li>Además es posible usar condiciones como en las rutas</li>
</ul>
</li>
</ul>
<pre><code class="ruby">before '/protected/*' do
  authenticate!
end

after '/create/:slug' do |slug|
  session[:last_slug] = slug
end

before :agent =&gt; /Songbird/ do
  # ...
end

after '/blog/*', :host_name =&gt; 'example.com' do
  # ...
end
</code></pre>
</section>
<section>

<h2>Helpers</h2>

<p>Son métodos que pueden ser usados en los bloques de rutas y los
templates.</p>
<pre><code class="ruby">helpers do
  def bar(name)
    "#{name}bar"
  end
end

get '/:name' do
  "#{bar params[:name]}"
end
</code></pre>
</section>
<section>

<h2>Sesiones</h2>

<p>Una sesión es usada para mantener el estado a través de
distintas peticiones. Cuando están activadas, proporciona un hash de sesión
para cada sesión de usuario:</p>
<pre><code class="ruby">enable :sessions

get '/' do
  "value = " &lt;&lt; session[:value].inspect
end

get '/:value' do
  session[:value] = params[:value]
end
</code></pre>
</section>
<section>

<h2>Redirecciones</h2>

<p>Podés redireccionar al navegador con el método redirect:</p>
<pre><code class="ruby">get '/foo' do
  redirect to('/bar')
end

get '/bar' do
  'Hello!'
end
</code></pre>
</section>
<section>

<h2>Manejo de errores</h2>

<p>Los manejadores de errores se ejecutan dentro del
mismo contexto que las rutas y los filtros before, lo que significa que podés
usar, por ejemplo, haml, erb, halt, etc.</p>
<pre><code class="ruby">not_found do
  'Ruta no encontrada'
end

error do
  # env['sinatra.error'] contains error
  'Disculpá, ocurrió un error horrible' 
end
</code></pre>
</section>
<section>

<h2>Configuración</h2>

<ul>
<li>Es posible correr, por única vez, código de incialización</li>
<li>Es posible hacerlo dependieno del <strong>ambiente</strong> indicado con la variable de
entorno <code>RACK_ENV</code>
</li>
</ul>

</section>
<section>

<h2>Configuración: Ejemplos</h2>
<pre><code class="ruby">configure do
  # setting one option
  set :option, 'value'

  # setting multiple options
  set :a =&gt; 1, :b =&gt; 2

  # same as `set :option, true`
  enable :option

  # same as `set :option, false`
  disable :option

  # you can also have dynamic settings with blocks
  set(:css_dir) { File.join(views, 'css') }
end

configure :production do
  # Sólo aplica al ambiente :production
end
</code></pre>
</section>
<section>

<h2>Configuración: accediendo a los valores</h2>

<p>Lo valores seteados con <code>set</code> pueden accederse con <code>settings</code></p>
<pre><code class="ruby">configure do
  set :foo, 'bar'
end

get '/' do
  settings.foo? # =&gt; true
  settings.foo  # =&gt; 'bar'
  ...
end
</code></pre>
</section>
<section>

<h2>Ambientes</h2>

<ul>
<li>Se utilizan 3 ambientes predefinidos: 

<ul>
<li><strong>production</strong></li>
<li><strong>test</strong></li>
<li><strong>development</strong></li>
</ul>
</li>
<li>Los ambientes se setean mediante la variable del entorno <code>RACK_ENV</code>
</li>
<li>El ambiente por defecto es <strong>development</strong>

<ul>
<li>En este ambiente, los templates se recargan en cada requerimiento</li>
<li>Los manejadores de <code>not_found</code> y <code>error</code> son especiales dado que muestran el
stacktrace</li>
</ul>
</li>
<li>En los ambientes <strong>production</strong> y <strong>test</strong> los templates se cachean  por
defecto</li>
</ul>

</section>
<section>

<h2>Ejemplo de ambientes</h2>

<p>La aplicación se inicia seteando la variable <code>RACK_ENV</code> de la siguiente forma:</p>
<pre><code class="bash">RACK_ENV=production ruby my_app.rb
</code></pre>
<pre><code class="ruby">get '/' do
  if settings.development?
    "development!"
  else
    "not development!"
  end
end
</code></pre>
</section>
<section>

<h2>Rack y Sinatra</h2>

<ul>
<li>Sinatra se apoya en <a href="https://github.com/rack/rack">rack</a>, una interface con el webserver modular</li>
<li>La capacidad más importante de rack es la de soportar <strong>middlewares</strong> 

<ul>
<li>Esto es, componentes que operan entre la aplicación y el web server
monitoreando o manipulando los reqs/resp HTTP proveyendo así de varios tipos
de funcionalidades comunes</li>
</ul>
</li>
<li>En sinatra, es simple utilizar los middlewares Rack con el método <code>use</code>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de uso de middleware rack</h2>
<pre><code class="ruby"># Agregando al Gemfile gem 'rack-contrib'
require 'bundler'
Bundler.require

use Rack::Deflater

get '/hello' do
  'Hello World'
end
</code></pre>
<p><small>
Ahora las respuestas se comprimen con <strong>gzip</strong>
</small></p>

</section>
<section>

<h2>Referencias</h2>

<p><a href="http://www.sinatrarb.com/">Sitio web de Sinatra</a></p>

</section>
</section>

<section>
<section>

<h1>Active Record</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Representa la M de MVC (el modelo)</li>
<li>Conecta clases a tablas de una base de datos estableciendo una capa de
persistencia</li>
<li>La librería provee una clase base que al heredarse, mapea la nueva clase
con una tabla existente de una base de datos</li>
</ul>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>En el contexto de una aplicación a estas clases suelen llamarselas <strong>modelos</strong>
</li>
<li>Los modelos pueden conectarse con otros modelos usando <strong>asociaciones</strong>
</li>
<li>Active Record se basa muchísimo en convenciones de nombres de forma tal que
utiliza el nombre de una clase o asociación para establecer mapeos con tablas
de la base de datos y claves foráneas.

<ul>
<li>A pesar de poder definir estos mapeos en forma explícita, es muy
recomendable seguir las convenciones de nombres, especialmente durante el
aprendizaje de la librería</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>ORM</h2>

<ul>
<li>Object Relational Mapping (ORM) es una técnica que conecta objetos de una
aplicación a tablas de un RDBMS. </li>
<li>Utilizando ORM, las propiedades y relaciones de los objetos en una aplicación
pueden ser fácilmente almacenados y recuperados de una base de datos <strong>sin</strong>
escribir SQL directamente, minimizando el código de base de datos</li>
</ul>

</section>
<section>

<h2>Active Record como Framework de ORM</h2>

<ul>
<li>Representa modelos y sus datos</li>
<li>Representa asociaciones entre los modelos</li>
<li>Representa herencia entre modelos</li>
<li>Validaciones de modelos antes de ser persistidos</li>
<li>Operaciones de bases de datos de forma orientada a objetos</li>
</ul>

</section>
<section>

<h2>Convention over configuration para Active Record</h2>

<ul>
<li>En la mayoría de los frameworks ORM es necesario configurar varios archivos
para comenzar a operar</li>
<li>En Active Record, si se siguen las convenciones adoptadas por Rails, será
necesario escribir muy pocas configuraciones (en algunos casos ninguna
configuración) para crear modelos</li>
<li>La configuración explícita será necesaria sólo cuando no pueda seguirse la
convención estandar</li>
</ul>

</section>
<section>

<h2>El primer ejemplo</h2>

<p>Active Record mapea automáticamente entre tablas y clases, atributos y
columnas</p>
<pre><code class="ruby">class Product &lt; ActiveRecord::Base
end
</code></pre>
<p>La clase <code>Product</code> <strong>se mapea automáticamente a la tabla llamada <code>products</code></strong>, que
podría ser algo como:</p>
<pre><code class="sql">CREATE TABLE products (
  id int(11) NOT NULL auto_increment,
  name varchar(255),
  PRIMARY KEY  (id)
);
</code></pre>
<p><small>
<strong>Además se definen los siguientes accessors: <code>Product#name</code> y
<code>Product#name=(new_name)</code></strong> <br>
<a href="images/samples/15/00-intro-ar.zip">Ver ejemplo</a>: <em>notar que no funcionará si no existe la tabla</em> creada <br>
<a href="https://github.com/TTPS-ruby/teoria/tree/master/images/samples/15/00-intro-ar">README</a>
</small></p>

</section>
<section>

<h2>Convenciones de nombres</h2>

<ul>
<li>Los nombres de las clases se pluralizan para encontrar las tablas

<ul>
<li>Por ejemplo <code>Book</code> se mapea a <code>books</code> </li>
<li>El mecanismo de pluralización (definido por Rails) es muy potente y puede
pluralizar (y singularizar) tanto palabras regulares como irregulares. </li>
<li>Cuando las clases se componen de más de una palabra, se utiliza <strong>CamelCase</strong> 
y el nombre de la tabla se compone de las palabras separadas por
underscores. Por ejemplo: la clase <code>BookClub</code> se mapeará a la tabla
<code>book_clubs</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de mapeos</h2>
<pre><code>
  +---------------+---------------+
  | Model / Class | Table / Schema|
  +---------------+---------------+
  | Post          | posts         |
  | LineItem      | line_items    |
  | Deer          | deers         |
  | Mouse         | mice          |
  | Person        | people        |
  +---------------+---------------+
</code></pre>
<p><small>
Ver <a href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html">ActiveSupport::Inflector</a>
</small></p>

</section>
<section>

<h2>Convenciones sobre los esquemas</h2>

<ul>
<li>Active Record utiliza convenciones para las columnas de las tablas,
dependiendo del propósito de estas columnas

<ul>
<li>
<strong>Claves foráneas:</strong> deben llamarse de la siguiente forma:
<code>nombre_en_singular_id</code> (por ejemplo: <code>item_id</code>, <code>order_id</code>). Estos serán
los campos por los que Active Record buscará cuando se creen asociaciones entre
modelos</li>
<li>
<strong>Claves primarias:</strong> por defecto, Active Record utilizará una columna de
tipo entero llamada <code>id</code> como clave primaria. Cuando se usan <em>Migraciones de
Active Record</em> para crear las tablas, esta columna se creará automáticamente</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Más convenciones sobre los esquemas</h2>

<ul>
<li>
<code>created_at</code>: esta columna automáticamente setea la fecha y hora cuando el
registro es creado</li>
<li>
<code>updated_at</code>: esta columna automáticamente setea la fecha y hora cuando el
registro es actualizado</li>
<li>
<code>lock_version</code>: agrega <a href="http://api.rubyonrails.org/classes/ActiveRecord/Locking/Optimistic.html">optimistic
locking</a> al modelo</li>
<li>
<code>type</code>: especifica que el modelo utiliza <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html#label-Single+table+inheritance">Single Table
Inheritance</a>
</li>
</ul>

</section>
<section>

<h2>Más convenciones sobre los esquemas</h2>

<ul>
<li>
<code>(association_name)_type</code>: especifica el tipo de <a href="http://edgeguides.rubyonrails.org/association_basics.html#polymorphic-associations">asociaciones
polimórifcas</a>
</li>
<li>
<code>(table_name_plural)_count</code>: usado para cachear el número de registros que pertenecen
a una asociación. Por ejemplo, una columna <code>comments_count</code> en la clase <code>Post</code> que tiene muchas instancias de <code>Comment</code>, cacheará el número de comentarios existentes para cada post.</li>
</ul>

</section>
<section>

<h2>Ejemplo de herencia, logs y cache</h2>

<ul>
<li>STI necesita que la clase que admita subclases tenga un campo type</li>
<li>Los logs se habilitan con: <code>ActiveRecord::Base.logger = Logger.new(STDOUT)</code>
</li>
<li>La cache de una asociaciòn se habilita con el campo <code>asociacion_en_plural_count</code> y agregando un modificador a la asociación <code>belongs_to</code> llamado <code>counter_cache: true</code>
</li>
</ul>

<p><small>
<a href="images/samples/15/00-intro-ar-logs-count-cache.zip">Descargar ejemplo</a> - <a href="https://github.com/TTPS-ruby/teoria/tree/master/images/samples/15/00-intro-ar-logs-count-count">Ver README</a>
</small></p>

</section>
<section>

<h2>Creando modelos en Active Record</h2>

<ul>
<li>Es muy simple crear modelos con Active Record

<ul>
<li>Simplemente se subclasea <code>ActiveRecord::Base</code> y listo</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class Product &lt; ActiveRecord::Base
end
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
</code></pre>
<ul>
<li>Esto creará el mapeo entre <code>Product</code> y la tabla <code>products</code>. </li>
<li>Además exisitrá el mapeo de cada campo en la tabla a accessors del objeto.</li>
</ul>

</section>
<section>

<h2>CRUD: Leyendo y escribiendo datos</h2>

<ul>
<li>CRUD significa <strong>C</strong>reate, <strong>R</strong>ead, <strong>U</strong>pdate, <strong>D</strong>elete</li>
<li>Active Record provee métodos que permiten a la aplicación leer y escribir
datos en las tablas</li>
</ul>

</section>
<section>

<h2>Creación</h2>

<ul>
<li>Los objetos Active Record pueden crearse desde:

<ul>
<li>Un Hash</li>
<li>Un bloque</li>
<li>Setear manualmente los atributos luego de la creación</li>
</ul>
</li>
<li>El método <code>new</code> retornará un objeto <strong>nuevo</strong> mientras que <code>create</code> retornará
un objeto y lo <strong>guardará</strong> en la base de datos</li>
</ul>
<pre><code class="ruby">user = User.create(name: "David",
                   occupation: "Code Artist")
# es lo mismo que:
user = User.new
user.name = "David"
user.occupation = "Code Artist"
user.save
</code></pre>
</section>
<section>

<h2>Creación con bloques</h2>
<pre><code class="ruby">user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
</code></pre>
<p><em>funciona tanto con <code>new</code> como <code>create</code></em></p>

</section>
<section>

<h2>Lectura</h2>

<p>Active Record provee una completa API para acceder a los datos de una base de
datos</p>
<pre><code class="ruby"># return a collection with all users
users = User.all

# return the first user
user = User.first

# find all users named David who are Code Artists and 
# sort by created_at inreverse chronological order
users = User.where(name: 'David', 
                   occupation: 'Code Artist').
                   order('created_at DESC')
</code></pre>
</section>
<section>

<h2>Actualización</h2>

<p>Una vez que un dato es recuperado, sus atributos pueden modificarse y luego
almacenarse en la base de datos nuevamente</p>
<pre><code class="ruby">user = User.find_by(name: 'David')
user.name = 'Dave'
user.save

# Lo mismo pero más corto
user = User.find_by(name: 'David')
user.update(name: 'Dave')

# Para cambios masivos
User.update_all "max_attempts = 3, must_change_pwd = 'true'"
</code></pre>
</section>
<section>

<h2>Eliminación</h2>

<p>De igual forma, una vez recuperado un objeto Active Record, podrá destruirse 
y a su vez eliminarse de la base de datos</p>
<pre><code class="ruby">user = User.find_by(name: 'David')
user.destroy
</code></pre>
</section>
<section>

<h2>Validaciones</h2>

<ul>
<li>Active Record permite validar el estado de un modelo antes de que sea escrito
a la base de datos</li>
<li>Existen varios mecanismos para validar y chequear que ciertos atributos no
sean blanco, no vacío, únicos, tener un formato específico, etc. </li>
</ul>

</section>
<section>

<h2>Validaciones</h2>

<ul>
<li>Las validaciones deben ser consideradas a la hora de persistir datos en la
base de datos

<ul>
<li>Por ello, los métodos como <code>create</code>, <code>save</code> y <code>update</code> consideran las
validaciones. </li>
<li>Retornan <code>false</code> cuando la validación falla y no actualizan el dato en la
base de datos</li>
<li>Todos estos métodos tiene sus correspondientes con bang! (<code>create!</code>,
<code>save!</code>y <code>update!</code>) que son estrictos en cuanto a lanzar una excepción <code>ActiveRecord::RecordInvalid</code>
cuando la validación falla.</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo de Validaciones</h2>
<pre><code class="ruby">class User &lt; ActiveRecord::Base
  validates :name, presence: true
end

User.create  
# =&gt; User not persisted
User.create! 
# =&gt; ActiveRecord::RecordInvalid: 
#    Validation failed: 
#    Name can't be blank
</code></pre>
</section>
<section>

<h2>Callbacks</h2>

<ul>
<li>Active Record callbacks permiten adjuntar código a ciertos eventos en el ciclo
de vida de los modelos.</li>
<li>Permiten agregar comportamiento a los modelos que es ejecutado de forma transparente 
cuando estos eventos suceden.</li>
<li>Pueden agregarse eventos cuando se crea un nuevo registro, al modificarse, al
eliminarse, etc.</li>
</ul>

</section>
<section>

<h2>Migraciones</h2>

<ul>
<li>Las migraciones son una DSL para el manejo de esquemas de bases de datos
llamados migraciones</li>
<li>Las migraciones se almacenan en archivos que son ejecutados contra una base de
datos soportada por Active Record usando <code>rake</code>
</li>
</ul>

</section>
<section>

<h2>Migraciones</h2>

<p>Ejemplo de una migración que crea una tabla</p>
<pre><code class="ruby">class CreatePublications &lt; ActiveRecord::Migration
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
</code></pre>
</section>
<section>

<h2>Migraciones</h2>

<ul>
<li>Las migraciones permiten tener un registro en la misma base de datos que
indica qué cambios se han aplicado</li>
<li>Los cambios entonces pueden versionarse y comitirse o deshacerse en la base de
datos</li>
<li>Para aplicar las migraciones pendientes: <code>rake db:migrate</code>
</li>
<li>Para deshacer un cambio hecho: <code>rake db:rollback</code>
</li>
<li>La DSL es agnóstico a la base de datos: funciona en MySQL, SQLite, Oracle,
Postgres, etc</li>
</ul>

<p><small>
<a href="images/samples/15/01-migrations.zip">Descargar ejemplo</a>
</small></p>

</section>
<section>

<h2>Alternativas a las Migraciones</h2>

<p>Otros productos que hacen algo similar:</p>

<ul>
<li><a href="https://flywaydb.org/">https://flywaydb.org/</a></li>
<li><a href="http://www.liquibase.org/">http://www.liquibase.org/</a></li>
</ul>

</section>
<section>

<h1>Active Record</h1>

<h2>validaciones</h2>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Garantizan que se guarden datos válidos en la base de datos</li>
<li>Hay alternativas:

<ul>
<li>Con validaciones en la DB como restricciones o store procedures, dificultan
la portabilidad de la aplicación a otros motores. Además no es simple
realizar los tests de la aplicación. Sin embargo, no es una mala práctica
aplicar restricciones en la base de datos</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Más alternativas

<ul>
<li>Del lado del cliente usando por ejemplo JS. Pero esta funcionalidad no
aplica a todos los usuarios, dado que un navegador puede no diponer de JS o
un usuario mal intencionado podría enviar datos no validados de forma
intencional</li>
<li>Validaciones en el controlador podría ser una alternativa. Sucede que el
testeo de los controladores se complejizaría. Por otra parte es una buena
idea mantener los controladores bien delgados</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Cuándo ocurren las validaciones?</h2>

<ul>
<li>Hay dos tipos de objetos en AR: 

<ul>
<li>Los que corresponden a una fila de la base de datos</li>
<li>Los que aún no están en la DB. Por ejemplo los objetos creados con <code>.new</code>
hasta que no se les diga <code>save</code>
</li>
</ul>
</li>
<li>Exite el método <code>.new_record?</code> que indica la situación de un objeto</li>
</ul>
<pre><code class="ruby">Person = Class.new(ActiveRecord::Base)
p = Person.new(name: "John Doe")
p.new_record?
p.save
p.new_record?
</code></pre>
</section>
<section>

<h2>¿Cuándo ocurren las validaciones?</h2>

<ul>
<li>Crear y guardar un objeto emite un <code>INSERT</code> a la DB</li>
<li>Actualizar un objeto emite un <code>UPDATE</code> a la DB

<ul>
<li>Antes de estas acciones, se realizan las validaciones. Si alguna de las validaciones <strong>falla</strong> 
entonces el objeto será marcado como <strong>inválido</strong> y ActiveRecord no realizará el
<code>INSERT</code> o <code>UPDATE</code>
</li>
</ul>
</li>
<li>Hay muchas formas de cambiar el estado de un objeto en la DB. Algunos métodos
realizarán validaciones, pero otros no, significando que podrían guardarse
datos <strong>inválidos</strong> en la DB</li>
</ul>

</section>
<section>

<h2>¿Cuándo ocurren las validaciones?</h2>

<p>Métodos que realizan validaciones</p>
<pre><code class="ruby">create
create!
save # Puede recibir validate: false
save!
update
update!
</code></pre>
<p>Métodos que NO realizan validaciones</p>
<pre><code class="ruby">decrement!
decrement_counter
increment!
increment_counter
toggle!
touch
update_all
update_attribute
update_column
update_columns
update_counters
</code></pre>
</section>
<section>

<h2>#valid? e #invalid?</h2>

<p>Independientemente de los métodos antes mencionados que lanzan las
validaciones, puede utilizarse <code>valid?</code> e <code>invalid?</code> para lanzar las
validaciones</p>
<pre><code class="ruby">class Person &lt; ActiveRecord::Base
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # =&gt; true
Person.create(name: nil).valid? # =&gt; false
</code></pre>
</section>
<section>

<h2>Los errores</h2>

<ul>
<li>Una vez que se realizaron las validaciones, AR almacenará los errores en
<code>errors.messages</code>, una colección de errores indexada por el campo con errores</li>
<li>Por definición un objeto será valido si la colección de errores es vacía luego
de correr las validaciones</li>
<li>Notar que un objeto creado con <code>new</code> que técnicamente es erróneo, no muestra
errores porque aún no se han corrido las validaciones</li>
</ul>

</section>
<section>

<h2>Helper: acceptance</h2>

<ul>
<li>Se utiliza específicamente en aplicaciones WEB donde se espera que un checkbox
sea tildado por el usuario</li>
<li>No es necesario que la base de datos tenga un atributo, sino que el helper
creará un campo virtual para este propósito</li>
</ul>
<pre><code class="ruby">class Person &lt; ActiveRecord::Base
  validates :terms_of_service, acceptance: true
end
</code></pre>
</section>
<section>

<h2>Helper: validates_associated</h2>

<ul>
<li>Valida las asociaciones relacionadas al objeto</li>
<li>No debe utilizarse en ambas partes de una asociación porque puede terminar en
<strong>loop infinito</strong>
</li>
</ul>
<pre><code class="ruby">class Library &lt; ActiveRecord::Base
  has_many :books
  validates_associated :books
end
</code></pre>
</section>
<section>

<h2>Helper: confirmation</h2>

<ul>
<li>Se utiliza cuando dos campos de texto deben contener el mismo dato: por
ejemplo que las direcciones de mail y su confirmación sean similares</li>
<li>El campo de confirmación no debe existir, sino que crea un campo virtual
llamado <code>_confirmation</code>
</li>
<li>El chequeo es realizado sólo si el campo <code>_confirmation</code> no es nil, por lo que
debe asegurarse su exsistencia</li>
</ul>
<pre><code class="ruby">class Library &lt; ActiveRecord::Base
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
</code></pre>
</section>
<section>

<h2>Helper: exclusion/inclusion</h2>

<p>Se utilizan para validar la (ex/in)clusión de valores admisibles </p>
<pre><code class="ruby">class Library &lt; ActiveRecord::Base
  validates :subdomain, 
    exclusion: { in: %w(www us ca jp)
end

class Coffee &lt; ActiveRecord::Base
  validates :size, 
    inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
</code></pre>
</section>
<section>

<h2>Helper: format</h2>

<p>Validan el formato con una expresión regular que se especifica usando la
opción <code>with:</code></p>
<pre><code class="ruby">class Product &lt; ActiveRecord::Base
  validates :legacy_code, format: { 
    with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
</code></pre>
</section>
<section>

<h2>Helper: length</h2>

<p>Valida la longitud de un campo de diversas formas</p>
<pre><code class="ruby">class Person &lt; ActiveRecord::Base
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
</code></pre>
</section>
<section>

<h2>Helper: numericality</h2>

<ul>
<li>Valida que el campo contenga sólo valores numéricos</li>
<li>Por defecto aceptará un signo opcional seguido de un entero o punto flotante</li>
<li>Para validar sólo enteros, puede usarse la opción <code>only_integer</code>

<ul>
<li>Además se admiten muchas otras opciones: <code>:greater_than</code>, <code>:greater_than_or_equal_to</code>, <code>:equal_to</code>, <code>:less_than</code>, <code>:less_than_or_equal_to</code>, <code>:odd</code>, <code>:even</code>
</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class Player &lt; ActiveRecord::Base
  validates :points, numericality: true
  validates :games_played, 
    numericality: { only_integer: true }
end
</code></pre>
</section>
<section>

<h2>Helper: presence/absence</h2>

<ul>
<li>Valida que el atributo esté o no presente (esté vacío) usando <code>blank?</code> para
verificar si un valor es <code>nil</code> o un string blanco (esto es vacío o consiste de
espacios)

<ul>
<li>Incluso permite validar que una asociación esté presente</li>
</ul>
</li>
</ul>
<pre><code class="ruby">class Person &lt; ActiveRecord::Base
  validates :name, :login, :email, presence: true
end

# Es importante para usar el siguiente ejemplo que la 
# asociación use inverse_of
class LineItem &lt; ActiveRecord::Base
  belongs_to :order
  validates :order, presence: true
end

class Order &lt; ActiveRecord::Base
  has_many :line_items, inverse_of: :order
end
</code></pre>
</section>
<section>

<h2>Helper: presence/absence</h2>

<ul>
<li>Dado que <code>false.blank?</code> es <code>true</code>, hay que tener especial cuidado con campos
booleanos</li>
<li>En el siguiente ejemplo se muestra de qué forma es posible eliminar la
posibilidad que el campo sea <code>nil</code>

<ul>
<li>Para el caso de <code>absence</code> es necesario algo como: <code>validates :field_name,
exclusion: { in: [true, false]</code> considerando que <code>false.present?</code> devuelve
<code>false</code>
</li>
</ul>
</li>
</ul>
<pre><code class="ruby">validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
</code></pre>
</section>
<section>

<h2>Helper: uniqueness</h2>

<ul>
<li>Valida la unicidad de un campo antes que sea guardado</li>
<li>No considera unicidad en la base de datos

<ul>
<li>Por lo que dos conexiones diferentes podrían crear el mismo dato que
esperamos sea único</li>
<li>Para evitar esto, es aconsejable agregar una restricción a nivel motor de la
DB</li>
</ul>
</li>
<li>Exite la posibilidad de explicitar un alcance de la unicidad de forma de
combinar con otros campos</li>
<li>Es posible especificar otra opción <code>case_sesitive</code> para verificar la unicidad
considerando este factor o no</li>
</ul>
<pre><code class="ruby">class Account &lt; ActiveRecord::Base
  validates :email, uniqueness: true
end
</code></pre>
</section>
<section>

<h2>Helper: uniqueness</h2>

<p>Más ejemplos</p>
<pre><code class="ruby">class Holiday &lt; ActiveRecord::Base
  validates :name, uniqueness: {
    scope: :year,
    message: "should happen once per year" }
end

class Person &lt; ActiveRecord::Base
  validates :name, 
    uniqueness: { case_sensitive: false }
end
</code></pre>
</section>
<section>

<h2>Validaciones condicionales</h2>

<ul>
<li>Algunas situaciones ameritan validar si un predicado es verdadero</li>
<li>Esto es posible con las opciones <code>:if</code> y <code>:unless</code> que reciben:
<code>Proc</code>, un string o arreglo

<ul>
<li>
<strong>Un símbolo:</strong> invocará un método del modelo</li>
<li>
<strong>Un string:</strong> se interpreta como código ruby como por ejemplo <code>validates
:surname, presence: true, if: "name.nil?"</code>
</li>
<li>
<strong>Un Proc:</strong> permite escribir código inline en vez de delegarlo a un método</li>
<li>
<strong>Un arreglo</strong>: combina multiples condiciones. Por ejemplo: <code>if:
["market.retail?", :desktop?]</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<p><a href="images/samples/15/02-validaciones.zip">Descargar ejemplo</a></p>

<p><a href="https://github.com/TTPS-ruby/teoria/tree/master/images/samples/15/02-validaciones">Ver
README</a></p>

</section>
<section>

<h1>Active Record</h1>

<h2>asociaciones</h2>

</section>
<section>

<h2>Introducción</h2>

<p>Las asociaciones simplifican la interacción entre modelos relacionados</p>

<h3>Asumamos los siguientes modelos</h3>
<pre><code class="ruby">class Customer &lt; ActiveRecord::Base
end

class Order &lt; ActiveRecord::Base
end
</code></pre>
</section>
<section>

<h2>Introducción</h2>

<p>Si Los clientes pueden tener varias órdenes, sin asociaciones, la forma de
relacionarlos sería:</p>
<pre><code class="ruby">@order = Order.create(order_date: Time.now, customer_id: @customer.id)

# Para eliminar un cliente con sus ordenes:
@orders = Order.where(customer_id: @customer.id)
@orders.each do |order|
  order.destroy
end
@customer.destroy
</code></pre>
</section>
<section>

<h2>La solución</h2>
<pre><code class="ruby">class Customer &lt; ActiveRecord::Base
  has_many :orders, dependent: :destroy
end

class Order &lt; ActiveRecord::Base
  belongs_to :customer
end

# Crear una orden:
@order = @customer.orders.create(order_date: Time.now)

# Eliminar un cliente:
@customer.destroy
</code></pre>
</section>
<section>

<h2>Tipos de asociaciones</h2>

<ul>
<li>Las asociaciones podrán ser alguna de:

<ul>
<li><code>belongs_to</code></li>
<li><code>has_one</code></li>
<li><code>has_many</code></li>
<li><code>has_many :through</code></li>
<li><code>has_one :through</code></li>
<li><code>has_and_belongs_to_many</code></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Asociación belongs_to</h2>

<ul>
<li>Arma una relación <strong>uno a uno</strong> con otro modelo</li>
<li>En general se usa combinado con una asociación <code>has_many</code> o <code>has_one</code> desde el otro modelo</li>
</ul>

<p><img src="images/15/belongs_to.png" alt="belongs_to"></p>

<p><small>
<strong>Ejemplo: Clientes con múltiples órdenes, donde cada orden es de un cliente</strong>
</small></p>

</section>
<section>

<h2>Asociación belongs_to</h2>

<ul>
<li>Es importante destacar que las asociaciones <code>belongs_to</code> deben usar términos
en singular.

<ul>
<li>En el ejemplo anterior si se hubiese utilizado <code>cutomers</code> en la asociación,
entonces surgiría un error indicando que <code>Order::Customers</code> es una constante
no inicializada</li>
<li>Esto se debe a que rails infiere el nombre de la clase a partir del nombre
de la asociación. </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Migración correspondiente al belongs_to</h2>
<pre><code class="ruby">class CreateOrders &lt; ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :orders do |t|
      t.belongs_to :customer, index: true
      t.datetime :order_date
      t.timestamps null: false
    end
  end
end
</code></pre>
</section>
<section>

<h2>Asociación has_one</h2>

<ul>
<li>Arma una relación <strong>uno a uno</strong> con otro modelo pero con una semántica diferente a la de <code>belongs_to</code>
</li>
<li>Esta asociación se utiliza para denotar relaciones uno a uno únicamente</li>
</ul>

<p><img src="images/15/has_one.png" alt="has_one"></p>

<p><small>
<strong>Ejemplo: Proveedores con una cuenta</strong>
</small></p>

</section>
<section>

<h2>Migración correspondiente al has_one</h2>
<pre><code class="ruby">class CreateSuppliers &lt; ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :accounts do |t|
      t.belongs_to :supplier, index: true
      t.string :account_number
      t.timestamps null: false
    end
  end
end
</code></pre>
<p><small>
<ul>
<li> Notar que <code>has_one</code> se coloca en la clase opuesta donde existe la clave foránea</li>
<li> Esto es porque su uso es similar a la asociación <code>has_many</code> pero se utilizará
  en casos de relaciones uno a uno en vez de uno a muchos</li>
</ul>
</small></p>

</section>
<section>

<h2>Asociación has_many</h2>

<ul>
<li>Arma una relación <strong>uno a muchos</strong> con otro modelo: este modelo puede tener 
cero o más instancias del modelo mencionado</li>
<li>Generalmente se encontrará en <em>el otro lado</em> de una asociación <code>belongs_to</code>
</li>
</ul>

<p><img src="images/15/has_many.png" alt="has_many"></p>

</section>
<section>

<h2>Migración correspondiente al has_many</h2>
<pre><code class="ruby">class CreateOrders &lt; ActiveRecord::Migration
  def change
    create_table :customers do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :orders do |t|
      t.belongs_to :customer, index: true
      t.datetime :order_date
      t.timestamps null: false
    end
  end
end
</code></pre>
<p><small>
Es similar a la migración del ejemplo del <code>belongs_to</code>
</small></p>

</section>
<section>

<h2>Asociación has_many :through</h2>

<ul>
<li>Generalmente usada en relaciones <strong>muchos a muchos</strong> con otro modelo</li>
<li>Esta asociación indica que el modelo que la declara puede disponer de cero o
más instancias del otro modelo, a través de un tercer modelo</li>
</ul>

</section>
<section>

<h2>Asociación has_many :through</h2>

<p>Turnos médicos que son solicitados por pacientes para ser atendidos por médicos</p>

<p><img src="images/15/has_many_through.png" alt="has_many_through"></p>

</section>
<section>

<h2>Asociación has_many :through</h2>
<pre><code class="ruby">class Physician &lt; ActiveRecord::Base
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment &lt; ActiveRecord::Base
  belongs_to :physician
  belongs_to :patient
end

class Patient &lt; ActiveRecord::Base
  has_many :appointments
  has_many :physicians, through: :appointments
end
</code></pre>
</section>
<section>

<h2>Migración correspondiente al has_many :through</h2>
<pre><code class="ruby">class CreateAppointments &lt; ActiveRecord::Migration
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :appointments do |t|
      t.belongs_to :physician, index: true
      t.belongs_to :patient, index: true
      t.datetime :appointment_date
      t.timestamps null: false
    end
  end
end
</code></pre>
</section>
<section>

<h2>Asociación has_one :through</h2>

<ul>
<li>Generalmente usada en relaciones <strong>uno a uno</strong> con otro modelo</li>
<li>Esta asociación indica que el modelo que la declara puede disponer de una
instancia de otro modelo accesible a través de un tercer modelo</li>
</ul>

</section>
<section>

<h2>Asociación has_one :through</h2>

<p>Un proveedor tiene una cuenta y cada cuenta tiene asociado un histórico de una la cuenta</p>

<p><img src="images/15/has_one_through.png" alt="has_one_through"></p>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="ruby">class Supplier &lt; ActiveRecord::Base
  has_one :account
  has_one :account_history, through: :account
end

class Account &lt; ActiveRecord::Base
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory &lt; ActiveRecord::Base
  belongs_to :account
end
</code></pre>
</section>
<section>

<h2>Migración correspondiente al has_one :through</h2>
<pre><code class="ruby">class CreateAccountHistories &lt; ActiveRecord::Migration
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :accounts do |t|
      t.belongs_to :supplier, index: true
      t.string :account_number
      t.timestamps null: false
    end

    create_table :account_histories do |t|
      t.belongs_to :account, index: true
      t.integer :credit_rating
      t.timestamps null: false
    end
  end
end
</code></pre>
</section>
<section>

<h2>Asociación has_and_belongs_to_many</h2>

<p>Crea una relación directa <strong>muchos a muchos</strong> con otro modelo sin un modelo interviniente</p>

</section>
<section>

<h2>Asociación has_and_belongs_to_many</h2>

<p><small>
Un montaje compuesto de muchas piezas, que puedan aparecer en muchos montajes
</small></p>

<p><img src="images/15/habtm.png" alt="habtm"></p>

</section>
<section>

<h2>Migración correspondiente a has_and_belongs_to_many</h2>
<pre><code class="ruby">class CreateAssembliesAndParts &lt; ActiveRecord::Migration
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps null: false
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps null: false
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly, index: true
      t.belongs_to :part, index: true
    end
  end
end
</code></pre>
</section>
<section>

<h2>Asociaciones polimórficas</h2>

<p>Un modelo puede pertenecer a uno o más modelos en una misma asociación</p>
<pre><code class="ruby">class Picture &lt; ActiveRecord::Base
  belongs_to :imageable, polymorphic: true
end

class Employee &lt; ActiveRecord::Base
  has_many :pictures, as: :imageable
end

class Product &lt; ActiveRecord::Base
  has_many :pictures, as: :imageable
end
</code></pre>
<p><small>
<strong>Una imagen puede pertenecer a un empleado o un producto</strong>
</small></p>

</section>
<section>

<h2>Asociaciones polimórficas</h2>

<ul>
<li>Desde una instancia de empleado es posible obtener las imágenes usando
<code>@employee.pictures</code>
</li>
<li>De igual forma es posible <code>@product.pictures</code>
</li>
<li>También es posible <code>@picture.imageable</code>
</li>
</ul>

</section>
<section>

<h2>Migración correspondiente a la asociación polimórfica</h2>
<pre><code class="ruby">class CreatePictures &lt; ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string  :name
      t.integer :imageable_id
      t.string  :imageable_type
      t.timestamps null: false
    end

    add_index :pictures, :imageable_id
  end
end
</code></pre>
</section>
<section>

<h2>Migración correspondiente a la asociación polimórfica</h2>
<pre><code class="ruby">class CreatePictures &lt; ActiveRecord::Migration
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true, index: true
      t.timestamps null: false
    end
  end
end
</code></pre>
</section>
<section>

<h2>Asociaciones conmigo mismo</h2>
<pre><code class="ruby">class Employee &lt; ActiveRecord::Base
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee"
end
</code></pre>
</section>
<section>

<h2>Migración</h2>
<pre><code class="ruby">class CreateEmployees &lt; ActiveRecord::Migration
  def change
    create_table :employees do |t|
      t.references :manager, index: true
      t.timestamps null: false
    end
  end
end
</code></pre>
</section>
<section>

<h2>Referencias</h2>

<ul>
<li><a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html">API</a></li>
<li><a href="http://edgeguides.rubyonrails.org/active_record_basics.html">Active Record base</a></li>
<li><a href="http://guides.rubyonrails.org/association_basics.html">Active Record Associations</a></li>
<li><a href="http://edgeguides.rubyonrails.org/active_record_querying.html">Active Record Querying</a></li>
<li><a href="http://edgeguides.rubyonrails.org/active_record_validations.html">Active Record Validations</a></li>
<li><a href="http://edgeguides.rubyonrails.org/active_record_callbacks.html">Active Record
Callbacks</a></li>
<li><p><a href="http://edgeguides.rubyonrails.org/migrations.html">Active Record Migrations</a></p></li>
<li>
<p>Desde Sinatra</p>

<ul>
<li><a href="https://github.com/janko-m/sinatra-activerecord">Active Record y Sinatra</a></li>
<li><a href="https://github.com/svenfuchs/micro_migrations">Active Record micro_migrations</a></li>
</ul>
</li>
</ul>

</section>
</section>

<section>
<section>

<p><img src="images/16/rails_logo.png" alt="Rails"></p>

<h1>Rails</h1>

</section>
<section>

<h2>Cómo funciona la web</h2>

<ul>
<li>Contenidos: HTML, imagenes, CSS, JS</li>
<li>Contenidos estáticos</li>
<li>Contenidos dinámicos

<ul>
<li>Porque se conecta a una DB / Servicio (Facebook)</li>
<li>Para simplificar el armado de un HTML modularizando el armado (partials)</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Qué es rails</h2>

<ul>
<li>Conjunto de estructuras y convenciones</li>
<li>Es una librería o conjunto de gemas</li>
<li>Al usar rails,  estaremos usando prácticas estandar que simplificarán la
colaboración y el mantenimiento del código</li>
<li>Promueve <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">Separation of Concerns (SoC)</a>, lo cual permite obtener programas modulares y mantenibles</li>
<li>El principal patrón de diseño que implementa es MVC</li>
</ul>

</section>
<section>

<h2>Stacks</h2>

<p>Un stack es un conjunto de tecnologías o librerías utilizadas para desarrollar
una aplicación o para servir una página</p>

<ul>
<li>Facebook usa algo como:

<ul>
<li>Linux (operating system)</li>
<li>Apache (web server)</li>
<li>MySQL (database)</li>
<li>PHP (programming language)</li>
</ul>
</li>
<li>Para el desarrollo con rails generalmente es:

<ul>
<li>Mac OS X, Linux, or Windows</li>
<li>WEBrick (web server)</li>
<li>SQLite (database)</li>
<li>Ruby on Rails (language and framework)</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Componentes y alternativas</h2>

<ul>
<li>Un clásico stack de rails será:

<ul>
<li>ERB for view templates</li>
<li>MySQL for databases</li>
<li>MiniTest for testing</li>
</ul>
</li>
<li>Una alternativa:

<ul>
<li>Haml for view templates</li>
<li>PostgreSQL for databases</li>
<li>Rspec for testing</li>
</ul>
</li>
</ul>

<p><small>
Las componentes podrán intercambiarse fácilmente, habiendo múltiples
alternativas. Seguir las tendencias o componentes populares es una buena
elección
</small></p>

</section>
<section>

<h2>Ayuda</h2>

<p>¿Cómo obtener ayuda?</p>

<ul>
<li>Google: pero considerar resultados actuales</li>
<li><a href="http://stackoverflow.com/questions/tagged/ruby-on-rails">Stack Overflow</a></li>
<li><a href="http://guides.rubyonrails.org/">Rails Guides</a></li>
<li><a href="http://api.rubyonrails.org/">Rails Documentation</a></li>
<li><a href="http://pragtob.github.io/rails-beginner-cheatsheet/index.html">Rails Begginer Chat Sheet</a></li>
<li><a href="http://railscasts.com/">Railscasts</a></li>
</ul>

</section>
<section>

<h2>Mantenerse actualizado</h2>

<ul>
<li><a href="http://rubyweekly.com/">Ruby Weekly</a></li>
<li><a href="http://www.rubyflow.com/">Ruby Flow</a></li>
<li><a href="http://ruby5.envylabs.com/">Ruby5</a></li>
</ul>

</section>
<section>

<h2>Instalando</h2>
<pre><code class="bash">
$ gem install rails
Successfully installed rails-x.y.z

$ rails -v
Rails x.y.z

</code></pre>
</section>
<section>

<h2>Exploramos el comando rails new</h2>

<ul>
<li>Es importante saber que disponemos de mensajes de ayuda para cada comando
rails</li>
<li>Rails provee el comando <code>rails new</code> para crear una aplicación Rails básica</li>
</ul>

<h3>Veamos la ayuda disponible para rails new:</h3>
<pre><code class="bash">
$ rails new --help

</code></pre>
<p><small>
<ul>
  <li>La ayuda puede parecer un tanto críptica a primera vista, pero es importante
      leer las opciones para ver qué alternativas tenemos.</li>
  <li>No usaremos ninguna opción en esta primer instancia</li>
  <li>Como resultado de la ejecución, se creará un directorio con carpetas y
      archivos en ella.</li>
</ul></small></p>

<p></p>

</section>
<section>

<h2>Creamos nuestra primer aplicación</h2>

<p>Primero creamos nuestra aplicación</p>
<pre><code class="bash">
$ rails new learn-rails

</code></pre>
<p><small>
El parámetro <strong>learn-rails</strong> indica el nombre del proyecto. Puede usarse
cualquier nombre
</small></p>

<p>Se instalarán varias gemas nuevas usando <code>bundler</code></p>
<pre><code class="bash">
$ cd learn-rails &amp;&amp; bundle

</code></pre>
</section>
<section>

<h2>Probando la nueva aplicación</h2>

<p>Con los pasos anteriores hemos creado una aplicación simple con valores por
defecto que ya puede usarse</p>

<h3>Iniciando el servidor web</h3>

<p><small>
Es posible iniciar la aplicación usando <code>rails server</code> o <code>rails s</code>
</small></p>
<pre><code class="bash">
$ bundle exec rails s
... Could not find a JavaScript runtime....

</code></pre>
<p><small>
Para solucionar este error debe instalarse <strong>nodejs</strong> o agregar la gema
<strong>therubyracer</strong> al <code>Gemfile</code> (notar que ya está pero comentada)
</small></p>

</section>
<section>

<h2>Iniciando el web server</h2>
<pre><code class="bash">$ bundle exec rails s
=&gt; Booting WEBrick
=&gt; Rails 4.0.1 application starting in development on http://0.0.0.0:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
[2013-11-30 19:41:53] INFO  WEBrick 1.3.1
[2013-11-30 19:41:53] INFO  ruby 2.0.0 (2013-06-27) [x86_64-linux]
[2013-11-30 19:41:53] INFO  WEBrick::HTTPServer#start: pid=15338 port=3000
</code></pre>
<ul>
<li>Visualizamos la aplicación accediendo a <a href="http://localhost:3000">http://localhost:3000</a>
</li>
<li>Observar que al usar el navegador, la consola donde se inició el web server
se actualiza con información

<ul>
<li>Estos mismos mensajes se van almacenando en <code>log/development.log</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Parando el web server</h2>

<ul>
<li>El web server puede pararse con <strong>Control+C</strong>
</li>
<li>No es necesario reiniciar el servidor en caso de modificar el proyecto</li>
<li>Los casos que requiere reiniciar son: 

<ul>
<li>Cuando se cambia el <code>Gemfile</code>
</li>
<li>Al cambiar archivos de configuración </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>La estructura del proyecto</h2>

<p>Carpetas y archivos importantes</p>

<table>
  <tr>
    <td>Gemfile</td>
    <td> Lists all the gems used by the application.</td>
  </tr>
  <tr>
    <td>Gemfile.lock</td>
    <td>Lists gem versions and dependencies.</td>
  </tr>
<tr>
    <td>README.rdoc</td>
    <td>A page for documentation.</td>
  </tr>
<tr>
    <td>app/</td>
    <td>Application folders and files.</td>
  </tr>
  <tr>
    <td>config/ </td>
    <td>Configuration folders and files.</td>
  </tr>
  <tr>
    <td>db/ </td>
    <td>Database folders and files.</td>
  </tr>
  <tr>
    <td>public/ </td>
    <td>Files for web pages that do not contain Ruby code, such as error
pages.</td>
  </tr>
</table>

</section>
<section>

<h2>Carpetas y archivos no tan importantes</h2>

<p><small>
No son importantes cuando estamos aprendiendo rails...
</small></p>

<table>
  <tr>
    <td>Rakefile</td>
    <td>Directives for the Rake utility program.</td>
  </tr>
  <tr>
    <td>bin/ </td>
    <td>Folder for binary (executable) programs.</td>
  </tr>
  <tr>
    <td>config.ru </td>
    <td>Configuration file for Rack (a software library for web servers).</td>
  </tr>
  <tr>
    <td>lib/</td> 
    <td>Folder for miscellaneous Ruby code.</td>
  </tr>
  <tr>
    <td>log/ </td>
    <td>Folder for application server logfiles.</td>
  </tr>
  <tr>
    <td>tmp/ </td>
    <td>Temporary files created when your application is running.</td>
  </tr>
  <tr>
    <td>vendor/ </td>
    <td>Folder for Ruby software libraries that are not gems.</td>
  </tr>
</table>

</section>
<section>

<h2>El directorio app/</h2>

<ul>
<li>Si listamos el contenido del directorio, nos encontramos con seis carpetas que
estarán presentes en todo proyecto rails:

<ul>
<li>assets</li>
<li>channels</li>
<li><strong>controllers</strong></li>
<li>helpers</li>
<li>jobs</li>
<li>mailers</li>
<li><strong>models</strong></li>
<li><strong>views</strong></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>El directorio app/</h2>

<ul>
<li>Aquí se hace evidente el patrón <em>model view controller</em>
</li>
<li>La carpeta <code>mailers/</code> contempla código para el envío de mails</li>
<li>La carpeta <code>helpers/</code> contiene <em>view helpers</em>, que son pequeñas porciones de
código reusable que generan HTML. Podríamos definirnos como macros que
expanden un pequeño comando en strings más extensos de tags HTML y contenido</li>
<li>La carpeta <code>assets/</code> contiene estilos CSS y Javascripts que son procesados
por <em>sprockets</em>
</li>
<li>La carpeta <code>channels/</code> contiene código de websockets</li>
<li>La carpeta <code>jobs/</code> contiene tareas asíncronas</li>
</ul>

</section>
<section>

<h2>Las Gemas de Rails</h2>

<ul>
<li>Rails en sí es una gema que, de hecho, requiere un conjunto de otras gemas

<ul>
<li>Esto puede verse en
<a href="https://rubygems.org/gems/rails">Rubygems</a>
</li>
</ul>
</li>
<li>Las gemas en que depende rails son:

<ul>
<li>
<a href="https://github.com/rails/rails/tree/master/actionmailer">actionmailer</a> - framework para envío de email y testing</li>
<li>
<a href="https://github.com/rails/rails/tree/master/actionpack">actionpack</a> - framework para el ruteo y respuestas a requerimientos WEB. <em>Es el VC de MVC</em>
</li>
<li>
<a href="https://github.com/rails/rails/tree/master/actionview">actionview</a> - framework para el manejo de templates y renderizado. <em>Es el V de MVC</em>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Las Gemas de Rails</h2>

<ul>
<li>Las gemas en que depende rails son:

<ul>
<li>
<a href="https://github.com/rails/rails/tree/master/activerecord">activerecord</a> - framework para la conexión a bases de datos. <em>Es el M de MVC</em>
</li>
<li>
<a href="https://github.com/rails/activeresource">activeresource</a> - framework para la abstracción de servicios REST. <em>Es el M' de MVC</em>
</li>
<li>
<a href="https://github.com/rails/rails/tree/master/activesupport">activesupport</a> - extensiones a Ruby y clases que proveen mayor funcionalidad</li>
<li>
<a href="http://gembundler.com/">bundler</a> - Manejo de gemas</li>
<li>
<a href="https://github.com/rails/rails/tree/master/railties">railties</a> - comandos de consola y generadores</li>
</ul>
</li>
</ul>

<p><small>
Estas gemas a su vez tienen dependencias, dando un total de aproximadamente 44
gemas
</small></p>

</section>
<section>

<h2>Más gemas</h2>

<ul>
<li>Además de la gema de rails, el comando <code>rails new</code> agrega otras gemas:

<ul>
<li>
<a href="https://github.com/luislavena/sqlite3-ruby">sqlite3</a> - adaptador para bases de datos SQLite</li>
<li>
<a href="https://github.com/rails/sass-rails">sass-rails</a> - habilita el uso de sintaxis SCSS para los estilos</li>
<li>
<a href="https://github.com/lautis/uglifier">uglifier</a> - compresor de JavaScript</li>
<li>
<a href="https://github.com/rails/coffee-rails">coffee-rails</a> - habilita el uso de sintaxis CoffeeScript para JavaScript</li>
<li>
<a href="https://github.com/rails/turbolinks">turbolinks</a> - técnica que acelera la carga de páginas web</li>
<li>
<a href="https://github.com/rails/jbuilder">jbuilder</a> - utilidad para la codificacion de datos en JSON</li>
<li><del><a href="https://github.com/rails/jquery-rails">jquery-rails</a> - agrega la librería JavaScript jQuery</del></li>
</ul>
</li>
</ul>

<p><small>
Puede que no se utilice ni SQLite, SCSS, jQuery u otras gemas, pero la mayoría
de los desarrollos las utilizan y por ello se consideran
</small></p>

</section>
<section>

<h2>Algunas gemas útiles</h2>

<p>De propósito general</p>

<ul>
<li>
<a href="https://github.com/thoughtbot/high_voltage">high_voltage</a> - Para la creación de páginas estáticas como <em>about</em>
</li>
<li>
<a href="https://github.com/laserlemon/figaro">figaro</a> - Para la configuracion del
proyecto</li>
<li>
<a href="https://github.com/plataformatec/simple_form">simple_form</a> - simplifica el uso de forms</li>
<li>
<a href="https://github.com/activerecord-hackery/ransack">ransack</a> - busquedas
simples</li>
<li>
<a href="https://github.com/amatsuda/kaminari">kaminari</a> - pager de modelos</li>
<li>
<a href="https://github.com/plataformatec/responders">responders</a> - código más
limpio en los controladores</li>
</ul>

</section>
<section>

<h2>Más gemas útiles</h2>

<p>Para mejorar el estilo visual</p>

<ul>
<li>
<a href="https://github.com/twbs/bootstrap-sass">bootstrap-sass</a> - Bootstrap 3 con Sass</li>
<li>
<a href="https://github.com/twbs/bootstrap-rubygem">bootstrap</a> - Bootstrap 4 con Sass</li>
<li>
<a href="https://github.com/Compass/compass-rails">compass-rails</a> - simplifica el manejo de estilos para poder usar <a href="http://foundation.zurb.com/">Zurb Fundation</a> por ejemplo</li>
<li>
<a href="https://github.com/zurb/foundation-rails">zurb-foundation</a> - Fundation on
rails projects</li>
<li>
<a href="https://github.com/rails/web-console">web-console</a> - simplifica la búsqueda de errores</li>
<li>
<a href="https://github.com/RailsApps/rails_layout">rails_layout</a> - genera archivos para el layout de la aplicación usando Twitter Bootstrap o Zurb Fundation</li>
</ul>

</section>
<section>

<h2>Más gemas útiles</h2>

<p>Para simplificar la labor de desarrollo</p>

<ul>
<li>
<a href="https://github.com/roidrage/lograge">lograge</a> - normaliza los logs</li>
<li>
<a href="https://github.com/roidrage/lograge">devise</a> - autenticación</li>
<li>
<a href="https://github.com/CanCanCommunity/cancancan">cancancan</a> - autorización</li>
<li>
<a href="https://github.com/mperham/sidekiq">sidekiq</a> - tareas asíncronas</li>
<li>
<a href="http://capistranorb.com/">capistrano</a> - despliegue automatizado</li>
<li><del><a href="https://github.com/evrone/quiet_assets">quiet_assets</a> - elimina mensajes
que distraen en los logs</del></li>
</ul>

</section>
<section>

<h2>Configuraciones</h2>

<ul>
<li>Rails es conocido por su lema: <strong>convention over configuration</strong>

<ul>
<li>Al aplicarlo, se reducen muchas configuraciones</li>
<li>No todas las configuraciones pueden eliminarse</li>
<li>Las aplicaciones requieren credenciales o API keys para poder funcionar</li>
</ul>
</li>
<li>El versionado con <strong>git</strong> debe evitar el guardado de estas credenciales</li>
</ul>

</section>
<section>

<h2>Configuraciones</h2>

<ul>
<li>Una buena práctica para configurar estos datos es usar variables de entorno
dado que:

<ul>
<li>La soportan todos SO como Windows, Mac y Linux, así como Heroku y otras
plataformas de deployment

<ul>
<li>Hoy muy usado en docker </li>
</ul>
</li>
<li>Las variables de ambiente pueden accederse desde ruby</li>
<li>Mantienen la privacidad del proyecto de forma independiente</li>
<li>La gema <strong><a href="https://github.com/laserlemon/figaro">figaro</a></strong> permite setear
variables desde el shell o desde un archivo de configuración</li>
<li>La gema <strong><a href="https://github.com/bkeepers/dotenv">dotenv-rails</a></strong> permite setear
variables desde un archivo <code>.env</code> en <code>ENV</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Cómo usar las variables de entorno</h2>

<ul>
<li>Las variables de entorno se usan mediante la constante <strong>ENV</strong>. </li>
<li>Supongamos que se necesita configurar en alguna parte de nuestra aplicación
rails, un servidor de mail</li>
</ul>
<pre><code class="ruby">config.action_mailer.smtp_settings = {
  address: "smtp.gmail.com",
  port: 587,
  domain: ENV["DOMAIN_NAME"],
  authentication: "plain",
  enable_starttls_auto: true,
  user_name: ENV["GMAIL_USERNAME"],
  password: ENV["GMAIL_PASSWORD"]
}
</code></pre>
<p><small>
¿De qué forma seteamos los valores <strong>DOMAIN_NAME</strong>, <strong>GMAIL_USERNAME</strong> y <strong>GMAIL_PASSWORD</strong>?
</small></p>

</section>
<section>

<h2>Como setear las variables con figaro</h2>

<p>Agregamos al <code>Gemfile</code></p>
<pre><code class="ruby">gem 'figaro'
</code></pre>
<p>Instalamos la gema con bundler</p>
<pre><code class="bash">$ bundle install
...
Using rails (4.0.1) 
Installing figaro (0.7.0) 
Using jbuilder (1.5.2) 
...
</code></pre>
</section>
<section>

<h2>Usando figaro</h2>

<ul>
<li>Esta gema setea las variables de entorno antes de hacer cualquier otra cosa</li>
<li>Los valores se leen desde un archivo: <code>config/application.yml</code>
</li>
<li>La gema entra en acción cuando se ejecute: <code>bundle exec figaro install</code>
</li>
<li>Al instalar figaro, se crea el archivo <code>config/application.yml</code> y apendea al
<code>.gitignore</code> que se ignore esta configuracion

<ul>
<li><em>De esta forma, los valores quedarán privados y no en el repositorio de git</em></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Usando figaro</h2>

<p>Instalando figaro</p>
<pre><code class="bash">$ bundle exec figaro install
    create  config/application.yml
    append  .gitignore
</code></pre>
<p>Editamos <code>config/application.yml</code></p>
<pre><code class="yaml">GMAIL_USERNAME: mygmailusername
GMAIL_PASSWORD: mygmailpassword
development:
  GMAIL_USERNAME: otherusername
  GMAIL_PASSWORD: otherpassword
</code></pre>
<p><small>
<em>Podemos setear las variables según el entorno</em>
<br><strong>Ojo con spring!</strong>
</small></p>

</section>
<section>

<h2>Páginas estáticas y ruteo</h2>

<ul>
<li>Una aplicación rails puede servir páginas estáticas como cualquier web server</li>
<li>Estas páginas no contienen código ruby

<ul>
<li>Esto hace que se sirvan de forma más rápida y usando menos recursos</li>
</ul>
</li>
<li>Empezar por crear páginas estáticas nos ayudará a entender el ruteo en rails</li>
</ul>

</section>
<section>

<h2>Agregamos la home page</h2>

<ul>
<li>Nos aseguramos tener iniciado el server rails: <code>bundle exec rails s</code>
</li>
<li>Ingresamos a <a href="http://localhost:3000/">http://localhost:3000/</a>

<ul>
<li>Veremos la página de información por defecto de rails</li>
</ul>
</li>
</ul>

<p><strong>Creemos el archivo <code>public/index.html</code></strong></p>
<pre><code class="html">
&lt;h1&gt; Hello World &lt;/h1&gt;

</code></pre>
<p><small>
<ul>
<li>Actualizamos la página y...</li>
<li>rails observará los cambios de la carpeta <code>public/</code>
</li>
<li>Si no se especifica ningun archivo en la URL, se asume <strong>index.html</strong>
  <ul>
  <li>La razón de este hecho data de 1993 con la creación del primer web server</li>
  </ul>
</li>
</ul></small></p>

<p>
</p>

</section>
<section>

<h2>Error de ruteo</h2>

<p><small>
¿Qué sucede si accedemos a <a href="http://localhost:3000/about.html">http://localhost:3000/about.html</a>?
</small></p>

<p><img src="images/16/01-routing-error.png" alt="routing error"></p>

</section>
<section>

<h2>Agregamos public/about.html</h2>
<pre><code class="html">
&lt;h1&gt; About &lt;/h1&gt;

</code></pre>
<p><em>Ahora todo debería funcionar bien</em></p>

</section>
<section>

<h1>Ruteo</h1>

</section>
<section>

<h2>Introduciendo el ruteo</h2>

<ul>
<li>El principio de <em>convention over configuration</em> gobierna el ruteo en rails</li>
<li>Si un navegador solicita <strong>index.html</strong> entonces Rails servirá la página desde
el directorio <code>public/</code> por defecto

<ul>
<li>No se necesita configuración para ello</li>
</ul>
</li>
<li>¿Si queremos cambiar este comportamiento?

<ul>
<li>Haremos que la home page sea ahora el about</li>
<li>Debemos <strong>eliminar</strong> public/index.html: <code>rm public/index.html</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Editamos config/routes.rb</h2>
<pre><code class="ruby">LearnRails::Application.routes.draw do
  root to: redirect('/about.html')
end
</code></pre>
</section>
<section>

<h1>Una reflexión</h1>

<ul>
<li>El caso anterior es un ejemplo de la <em>magia de rails</em> </li>
<li>Algunos desarrolladores consideran que <em>convention over configuration</em> es
<strong>magia negra</strong>
</li>
<li>No es obvio el por qué las páginas se sirven de <code>public/</code>
</li>
<li>Si se desconoce esta convención, podemos rompernos la cabeza buscando donde se
mapea que http://localhost:3000 sirva <code>public/index.html</code>

<ul>
<li>El código que implementa esto, está enterrado profundamente en el corazón de
rails</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Request &amp; response</h2>

<ul>
<li>Analizaremos el patron MVC desde la perspectiva de la web</li>
<li>Debemos considerar que la WEB no es más que navegadores que solicitan páginas
a un servidor</li>
<li>Los navegadores realizan <strong>requerimientos</strong> (request)</li>
</ul>

</section>
<section>

<h2>Request &amp; response</h2>

<ul>
<li>Los servidores <strong>responden</strong> (response) a estos requerimientos, enviando, por ejemplo, un
HTML.

<ul>
<li>Dependiendo en los encabezados del HTML, el navegador deberá realizar más
requerimientos para obtener estilos, javascripts e imagenes</li>
</ul>
</li>
<li>La simplicidad de HTTP hace que no haya más que los requerimientos de un
navegador y las respuestas de un servidor

<ul>
<li>Hoy día existe además el streaming de audio/video que requieren un pipe
entre el navegador y el servidor, pero aún así, un requerimiento y respuesta inicial 
hacen posible la incialización del stream</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>El ciclo request / response</h2>

<p><img src="images/16/02-request-response.png" alt="request repsonse"></p>

</section>
<section>

<h2>Analizando el ciclo desde el navegador</h2>

<ul>
<li>Es aconsejable usar <a href="https://www.google.com/chrome">Google Chrome</a>
</li>
<li>Antes de investigar algo, es conveniente utilizar el <strong>modo incógnito</strong>: que
se accede usando <strong>Shift+Ctrl+N</strong> (<strong>Shift+Ctrl+P</strong> en Firefox)

<ul>
<li>Alternativamente puede limpiarse la caché del navegador para así limpiar
cualquier solicitud previamente cacheada por el navegador </li>
</ul>
</li>
<li>Abrimos la vista <em>Developer Tools</em> usando <strong>Shift+Ctrl+I</strong>

<ul>
<li>Seleccionamos el tab <strong>Network</strong>
</li>
<li>Realizamos el requerimiento <a href="http://localhost:3000/about.html">http://localhost:3000/about.html</a>
</li>
<li>Visualizaremos los archivos recibidos desde el servidor: sólo uno
<strong>about.html</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Analizando el ciclo desde el navegador</h2>

<p>Así debe verse el requerimiento</p>

<p><img src="images/16/03-navegador-ok.png" alt="ejemplo chrome ok"></p>

</section>
<section>

<h2>Analizando el ciclo desde el navegador</h2>

<p>Notar cuando no es "fresco" el requerimineto</p>

<p><img src="images/16/03-navegador-not-ok.png" alt="ejemplo chrome ok"></p>

</section>
<section>

<h2>El detalle del requerimiento</h2>

<p><small>
Cliqueando sobre el nombre del archivo, y luego sobre la solapa <strong>Headers</strong>, se visualiza el detalle del requerimiento y su respuesta
</small></p>

<p><img src="images/16/04-navegador-detalle.png" alt="ejemplo chrome detalle"></p>

</section>
<section>

<h2>Analizamos lo que muestra el navegador</h2>

<ul>
<li>Que el requerimiento se compone de:

<ul>
<li>Un request a la URL http://localhost:3000/about.html </li>
<li>Que el método HTTP empleado fue GET</li>
<li>Los headers del request incluyendo cookies y el identificador del UA</li>
</ul>
</li>
<li>La respuesta se compone de:

<ul>
<li>El código de estado: 200 OK o 304 Not modified</li>
<li>Los headers de la respuesta: incluyendo fecha y hora, así como el
identificador del servidor</li>
<li>HTML</li>
</ul>
</li>
</ul>

<p><small>
Ahora podemos analizar cómo el requerimiento a <strong>http://localhost:3000/</strong>
devuelve dos entradas por el redirect
</small></p>

</section>
<section>

<h2>Analizamos ahora desde el lado del servidor</h2>

<ul>
<li>Hasta ahora vimos las herramientas que disponemos desde el navegador

<ul>
<li>Pero no podemos visualizar qué es lo que sucede en el servidor</li>
</ul>
</li>
</ul>

<p><strong>La ventana de consola del servidor muestra:</strong></p>
<pre><code class="bash">
Started GET "/" for 127.0.0.1 at ...

</code></pre>
<p><small>
Es importante destacar que no hay logs para los archivos servidos desde la
carpeta <code>public/</code>
</small></p>

</section>
<section>

<h1>Model View Controller</h1>

</section>
<section>

<h2>MVC en la web</h2>

<p>El siguiente gráfico muestra qué sucede en el servidor durante el ciclo
request-response </p>

<p><img src="images/16/05-ciclo-completo-rails.png" alt="ciclo request response"></p>

<p><small>
Algunos expertos opinan que la arquitectura de la web no se ajusta al original
diseño de MVC creado para aplicaciones visuales de escritorio
</small></p>

</section>
<section>

<h2>MVC en rails</h2>

<p><img src="images/16/06-mvc-rails.png" alt="MVC en rails"></p>

</section>
<section>

<h2>MVC en rails</h2>

<ul>
<li>En la base del stack está el navegador: el requerimiento fluye subiendo por
las capas hasta llegar al <strong>router</strong> que despachará al controlador apropiado</li>
<li>Existe un único <code>config/routes.rb</code> y múltiples controladores, modelos y vistas</li>
<li>El controlador, al recibir el flujo, obtendrá datos de algún <strong>modelo</strong>
</li>
<li>Con los datos listos, el controlador renderizará la respuesta combinando los
datos del modelo con una componente de <strong>vista</strong> que provea layout y markup</li>
</ul>

</section>
<section>

<h2>MVC en rails</h2>

<ul>
<li>Los archivos del model, controller y view serán código ruby</li>
<li>Cada archivo tendrá una estructura y sintaxis específica basada en cómo se ha
definido por el mismo framework</li>
<li>Cada model, view y controller que creemos <em>heradará</em> comportamiento de
superclases que son parte del farmework, minimizando lo que debemos codificar</li>
</ul>

</section>
<section>

<h2>Models en Rails</h2>

<ul>
<li>En la mayor parte de las aplicaciones rails, un modelo obtiene datos de una base de datos</li>
<li>Sin embargo, en otros casos se obtienen de conexiones a otros servidores</li>
<li>Ejemplos:

<ul>
<li>El model <strong>User</strong> podría obtener el nombre y email desde una base de datos
local</li>
<li>El mismo modelo, podría además obtener los tweets recientes de Twitter para
este mismo usuario, o la ciudad en la que vive desde Facebook</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Controllers en Rails</h2>

<ul>
<li>Un controlador podría obtener datos de más de un modelo si fuera necesario</li>
<li>Generalmente un controlador posee más de una <strong>acción</strong>.
Por ejemplo, un controlador para User podría tener acciones para listar los
usuarios, agregar o eliminar un usuario de la lista</li>
<li>El archivo <code>config/routes.rb</code> macheará el requermiento web a una acción del
controlador</li>
<li>En Rails se trata de limitar las acciones en un controlador a las siete
acciones siguientes: <code>index</code>, <code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code> y
<code>destroy</code>

<ul>
<li>Un controlador que implementa estas acciones se dice que es <strong>RESTful</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Views en Rails</h2>

<ul>
<li>Una vista combina código ruby con markup HTML. </li>
<li>Generalmente tendremos una vista asociada a cada acción de un controlador

<ul>
<li>Una vista para <strong>index</strong> debería mostrar una lista de usuarios</li>
<li>La vista <strong>show</strong> proveerá detalles del perfil de un usuario</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Views en Rails</h2>

<ul>
<li>Las vistas tendrán una sintaxis muy similar a HTML convencional, pero con
algunos datos que se extraen de variables ruby o estructuras de control como
loops que permitirán crear tablas.

<ul>
<li>Siguiendo el principio de Separation of Concerns, es considerada una buena práctica limitar el
uso de código ruby en las vistas a sólo utilizarlo para imprimir valores de
variables.</li>
<li>Cualquier otra cosa será responsabilidad del modelo</li>
</ul>
</li>
<li>No todas las acciones tendrán una vista: por ejemplo la acción <strong>destroy</strong>
usualmente redirige al <strong>index</strong>, y <strong>create</strong> redirige o al <strong>show</strong> o al
<strong>new</strong>
</li>
</ul>

</section>
<section>

<h2>Home dinámica</h2>

<p><em>Planificamos nuestro trabajo definiendo un User story</em></p>

<p><strong>Birthday countdown</strong></p>

<ul>
<li>As a visitor to the website

<ul>
<li>I want to see the owner's name</li>
<li>I want to see the owner's birthdate</li>
<li>I want to see how many days until the </li>
<li>  owner's next birthday</li>
<li>In order to send birthday greetings</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>La elección de nombres</h2>

<ul>
<li>Mucho en el arte de la programación radica en elegir nombres correctos para
nuestras creaciones</li>
<li>Necesitamos un modelo que represente el site owner. 

<ul>
<li>Elegiremos el nombre más obvio: <strong>Owner</strong> y cremos el archivo
<code>app/models/owner.rb</code>
</li>
</ul>
</li>
<li>El nombre del controlador abre otro debate

<ul>
<li>Nos podríamos tentar por <em>Home controller</em> o <em>Welcome controller</em>
</li>
<li>Si bien son nombres aceptables, si consideramos el <strong>User Story</strong> el nombre
<strong>Visitors controller</strong> es más adecuado porque <strong>visitor</strong> es el actor</li>
<li>Creamos entonces <code>app/controllers/visitors_controller.rb</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Convenciones de nombres</h2>

<ul>
<li>En rails es importante como se llaman los archivos y clases definidas en
ellos.</li>
<li>Esto se debe al principio CoC</li>
<li>Esto evita configuraciones innecesarias</li>
<li>Al escribir código

<ul>
<li>
<code>class Visitor &lt; ActiveRecord::Base</code> <em>los nombres de las clases de modelo
son en singular y en mayúscula</em>
</li>
<li>
<code>class VisitorsController &lt; ApplicationController</code> <em>los nombres de
controladores son la combinación de un nombre de modelo en plural con
<strong>Controller</strong> en camel case</em>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Convenciones de nombres</h2>

<ul>
<li>Los archivos:

<ul>
<li>Los archivos de modelo coinciden con el nombre del modelo , pero en
minúscula: <code>app/models/visitor.rb</code>
</li>
<li>Los archvios de controlador coinciden con la clase, pero usando snake case:
<code>app/controllers/visitors_controller.rb</code>
</li>
<li>La carpeta de las vistas coinciden con el nombre de la clase del modelo,
pero en plural y en minúscula: <code>app/views/visitors</code>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Routing</h2>

<p>Crearemos primero el ruteo antes de implementar el model y controller</p>

<h3>Editamos config/routes.rb</h3>
<pre><code class="ruby">LearnRails::Application.routes.draw do
  root to: 'visitors#new'
end
</code></pre>
<ul>
<li>Notar el modulo <strong>LearnRails</strong> como prefijo

<ul>
<li>Esto se debe al nombre de la aplicación que creamos con el comando <code>rails
new learn_rails</code>
</li>
</ul>
</li>
<li>Los detalles de la sintaxis de este archivo puede 
entenderse bien leyendo <a href="http://guides.rubyonrails.org/routing.html">Routing from outside in</a>
</li>
<li>Modificando <code>config/routes.rb</code> no requiere reiniciar</li>
</ul>

</section>
<section>

<h2>Probamos http://localhost:3000</h2>

<p>Esperamos obtener un error</p>

<p><img src="images/16/07-no-better-errors.png" alt="Error sin better errors"></p>

<p>El error es claro: <strong>uninitialized constant VisitorsController</strong> indicando que
Rails busca la clase y no puede encontrarla</p>

<p><small>
Podemos mejorar el error agregando la gema <code>better_errors</code> al <code>Gemfile</code>
</small></p>

</section>
<section>

<h2>El modelo</h2>

<ul>
<li>La mayoría de los modelos rails obtienen datos desde una base de datos</li>
<li>Cuando se utiliza una base de datos, es posible usar el comando: <code>rails
generate model</code> para crear un modelo que hereda de <strong>ActiveRecord</strong>
y conoce como conectarse con la base de datos</li>
<li>Para este ejemplo no necesitamos una base de datos

<ul>
<li>Nuestra clase simplemente definirá los métodos necesarios</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Implementamos el Modelo</h2>
<pre><code class="ruby">class Owner
  def name
    'Foobar Kadigan'
  end

  def birthdate
    Date.new(1990, 12, 22)
  end

  def countdown
    today = Date.today
    birthday = Date.new(today.year, 
            birthdate.month, 
            birthdate.day)
    if birthday &gt; today
      countdown = (birthday - today).to_i
    else
      countdown = (birthday.next_year - today).to_i
    end
  end

end
</code></pre>
</section>
<section>

<h2>La Vista</h2>

<ul>
<li>Como ya mencionamos en las convenciones de nombres, las vistas van en
<code>app/views/</code>
</li>
<li>En una aplicación convencional, un controlador puede renderizar múltiples
vistas, por lo tanto se crea un directorio para cada controlador

<ul>
<li>En nuestro caso creamos <code>mkdir app/views/visitors</code>
</li>
</ul>
</li>
</ul>

<p><strong>Creamos entonces <code>app/views/visitors/new.html.erb</code></strong></p>
<pre><code class="html">&lt;h3&gt;Home&lt;/h3&gt;
&lt;p&gt;Welcome to the home of &lt;%= @owner.name %&gt;.&lt;/p&gt;
&lt;p&gt;I was born on &lt;%= @owner.birthdate %&gt;.&lt;/p&gt;
&lt;p&gt;Only &lt;%= @owner.countdown %&gt; days until my birthday!&lt;/p&gt;
</code></pre>
</section>
<section>

<h2>La Vista</h2>

<ul>
<li>Con lo anterior tenemos únicamente la vista <strong>new</strong> para el controlador
visitor</li>
<li>La extensión es <strong>erb</strong> porque usamos el motor ERB para armar nuestros
templates</li>
<li>En el ejemplo, y por defecto en rails, se utiliza ERB, pero es posible utilizar gemas que
proveen <a href="http://railsapps.github.io/rails-haml.html">Haml</a> o <a href="http://slim-lang.com/">Slim</a> como motores de templating. 

<ul>
<li>Si usaramos por ejemplo haml, la vista sería <strong>new.html.haml</strong>
</li>
</ul>
</li>
<li>En la vista, podemos ver que el markup de ERB utiliza los tags <code>&lt;%=</code> y
<code>%&gt;</code>
</li>
</ul>

</section>
<section>

<h2>La Vista</h2>

<ul>
<li>El acceso a los datos del modelo <strong>Owner</strong> se hace a través de <code>@owner</code>

<ul>
<li>Esto se entenderá mejor cuando creemos el controlador</li>
</ul>
</li>
</ul>

<p><strong>Podríamos preguntarnos por qué usar:</strong></p>
<pre><code class="erb">&lt;%= @owner.countdown %&gt;
</code></pre>
<p>en vez de</p>
<pre><code class="erb">&lt;%= (Date.new(today.year, @owner.birthdate.month, @owner.birthdate.day) - Date.today).to_i %&gt;
</code></pre>
<p><small>
  Podríamos hacerlo, pero violaríamos SoC
</small></p>

</section>
<section>

<h2>El controlador</h2>

<ul>
<li>Será el <em>pegamento</em> entre el modelo Owner y la vista
<strong>VisitorsController#new</strong>

<ul>
<li>Cuando hagamos referencia a una acción en un controlador, usaremos la
notación <em>VisitorsController#new</em> uniendo el nombre de la clase del
controlador con el de la acción (que es un método). En este contexto, el
caracter <strong>#</strong> es una convención usada en la documentación </li>
<li>El nombre de la clase será <code>VisitorsController</code> pero el nombre del archivo
<strong>visitors_controller.rb</strong>
</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Escribimos el controlador</h2>

<p>Creamos <code>app/controllers/visitors_controller.rb</code></p>
<pre><code class="ruby">class VisitorsController &lt; ApplicationController
  def new
    @owner = Owner.new
  end
end
</code></pre>
<p><strong>¿Qué hace?</strong></p>

<ul>
<li>Al ser subclase de ApplicationController hereda todo el comportamiento
definido por la API de rails</li>
<li>Solo implementa el método <code>new</code>

<ul>
<li>Creamos una variable de instancia <code>@owner</code> dado que en la vista
correspondiente estará disponible. </li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Relación controlador y vista</h2>

<ul>
<li>Ya creamos una vista llamada <code>app/views/visitors/new.html.erb</code>
</li>
<li>El controlador es muy simple dado que el comportamiento oculto que invoca la
vista <em>new</em> es heredado de la API de rails.

<ul>
<li>Podemos hacer explícita esta relación</li>
</ul>
</li>
</ul>

<p><strong>Indicando qué vista usar en el controlador</strong></p>
<pre><code class="ruby">class VisitorsController &lt; ApplicationController
  def new
    @owner = Owner.new
    render 'visitors/new'
  end
end
</code></pre>
</section>
<section>

<h2>Scaffolding</h2>

<ul>
<li>La mejor forma de entender la arquitectura MVC de rails es examinando cada una
de las partes como hemos hecho hasta aquí</li>
<li>Si se lee la guía de rails: <a href="http://guides.rubyonrails.org/getting_started.html">Getting Started with Rails</a> veremos que se utiliza mucho el comando <code>rails generate scaffold</code> que permite crear MVC en una única operación

<ul>
<li>Esta operación es muy usada para desarrollar módulos simples en rails</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Resolviendo problemas</h2>

<ul>
<li>Veremos algunas técnicas que ayudan a resolver problemas

<ul>
<li>Rails console</li>
<li>Rails logger</li>
<li>Stack trace</li>
<li>Raising exceptions</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Rails console</h2>

<ul>
<li>IRB solamente evalúa expresiones que son definidas por la API de ruby</li>
<li>IRB no conoce las clases de rails</li>
<li>Rails console carga toda la aplicación rails en una consola IRB</li>
</ul>
<pre><code class="bash">$ bundle exec rails console
Loading development environment (Rails X.Y.Z)
irb(main):001:0&gt; 
</code></pre>
<p><small>
<em>Notamos que se cargó el ambiente de development</em>
</small></p>

</section>
<section>

<h2>Rails console</h2>

<p>Inspeccionamos el modelo</p>
<pre><code class="bash">irb(main):001:0&gt; owner = Owner.new
=&gt; #&lt;Owner:0x007f7eccd77e48&gt;

irb(main):002:0&gt; owner.name
=&gt; "Foobar Kadigan"
</code></pre>
</section>
<section>

<h2>Rails logger</h2>

<ul>
<li>Las aplicaciones rails envían información de diagnóstico a un <em>archivo de log</em>
</li>
<li>Dependiendo del ambiente en el que corre la aplicación, el log será:

<ul>
<li><strong>log/development.log</strong></li>
<li><strong>log/production.log</strong></li>
</ul>
</li>
<li>En el ambiente de desarrollo, todo log escrito en el archivo es además enviado
a la consola de donde se corre el comando <code>rails server</code>
</li>
<li>Además de los logs por defecto de rails, podemos usar nosotros <strong>logger</strong>
</li>
</ul>

</section>
<section>

<h2>Rails logger</h2>

<p>Modificamos <code>app/controllers/visitors_controller.rb</code></p>
<pre><code class="ruby">class VisitorsController &lt; ApplicationController
  def new
    Rails.logger.debug 'DEBUG: entering new method'
    @owner = Owner.new
    Rails.logger.debug "DEBUG: Owner name is #{@owner.name}"
  end
end
</code></pre>
<p>Ahora la salida en la consola será</p>
<pre><code class="bash">Started GET "/" for 127.0.0.1 at ...
Processing by VisitorsController#new as HTML
DEBUG: entering new method
DEBUG: Owner name is Foobar Kadigan
Rendered visitors/new.html.erb within layouts/application (0.2ms)
Completed 200 OK in 8ms (Views: 4.6ms | ActiveRecord: 0.0ms)
</code></pre>
</section>
<section>

<h2>Rails logger</h2>

<ul>
<li>Podemos usar <strong>Rails.logger</strong> en nuestros modelos</li>
<li>En los controladores, es posible usar el método <strong>logger</strong> directamente</li>
<li>Es posible usar:

<ul>
<li><code>logger.debug</code></li>
<li><code>logger.info</code></li>
<li><code>logger.warn</code></li>
<li><code>logger.error</code></li>
<li><code>logger.fatal</code></li>
</ul>
</li>
<li>En el ambiente de desarrollo todos los logs se mostrarán</li>
<li>En el ambiente de producción no se visualizarán los logs enviados a
<code>logger.debug</code>
</li>
</ul>

</section>
<section>

<h2>El Stack Trace</h2>

<ul>
<li>Si bien el logger es muy útil, hay casos en donde el programa se colgará y la
consola mostrará un <em>stack trace</em>
</li>
<li>Provocamos un error agregando en el controlador un error</li>
</ul>

<p><strong>Generamos el error</strong></p>
<pre><code class="ruby">class VisitorsController &lt; ApplicationController
  def new
    Rails.logger.debug 'DEBUG: entering new method'
    @owner = Owner.new
    Rails.logger.debug 'DEBUG: Owner name is ' + @owner.name
    DISASTER
  end
end
</code></pre>
<p><small>En vez de DISASTER, podría haberse usado <code>console</code> proporcionado por
<strong>web-console</strong></small></p>

</section>
<section>

<h2>Al ingresar a la página veremos</h2>

<p><img src="images/16/08-stacktrace.png" alt="error stack trace"></p>

</section>
<section>

<h2>El Stack Trace</h2>

<p>La captura muestra el error así porque usamos la gema <strong>web-console</strong></p>

<h3>En la consola veremos</h3>
<pre><code class="bash">Started GET "/" for 127.0.0.1 at 2013-12-08 20:09:18 -0300
Processing by VisitorsController#new as HTML
DEBUG: entering new method
DEBUG: Owner name is Foobar Kadigan
Completed 500 Internal Server Error in 2ms

NameError - uninitialized constant VisitorsController::DISASTER:
  activesupport (4.0.1) lib/active_support/dependencies.rb:501:in `load_missing_constant'
  ...
</code></pre>
</section>
<section>

<h2>El Stack Trace</h2>

<ul>
<li>No hay que sentirse abrumado por la cantidad de información</li>
<li>Muchas veces la explicación del problema está en la primer línea</li>
<li>Otras veces tenemos que avanzar sobre la pila leyendo cuidadosamente el
problema</li>
</ul>

</section>
<section>

<h2>Lanzando excepciones</h2>

<ul>
<li>El ejemplo del stack trace hace uso de una directiva desconocida por rails</li>
<li>Una solución más elegante sería lanzar una excepción</li>
</ul>
<pre><code class="ruby">class VisitorsController &lt; ApplicationController
def new
  Rails.logger.debug 'DEBUG: entering new method'
    @owner = Owner.new
    Rails.logger.debug ".."
    raise 'Deliberate Failure'
  end
end
</code></pre>
<h3>Más recursos...</h3>

<p><a href="http://guides.rubyonrails.org/debugging_rails_applications.html">RailsGuide: Debugging Rails Applications</a></p>

</section>
<section>

<h2>Referencias</h2>

<ul>
<li><a href="http://learn-rails.com/learn-ruby-on-rails.html">Learn Ruby on Rails</a></li>
<li><a href="http://guides.rubyonrails.org/">Rails Guides</a></li>
<li><a href="http://api.rubyonrails.org/">Rails Documentation</a></li>
<li><a href="http://pragtob.github.io/rails-beginner-cheatsheet/index.html">Rails Beginner Cheat Sheet</a></li>
<li><a href="http://railscasts.com/">Railscasts</a></li>
<li><a href="http://37signals.com/svn/posts/3372-put-chubby-models-on-a-diet-with-concerns">Uso de concerns: como poner a dieta los modelos regordetes</a></li>
</ul>

</section>
</section>
